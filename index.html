<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Tournament Sim</title>
    <style>
        /* ... (Exact same CSS as before) ... */
        body { font-family: sans-serif; margin: 0; padding: 0; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; color: #333; height: 100vh; overflow: hidden; }
        .container { display: flex; width: 95%; max-width: 1400px; margin-top: 10px; height: calc(100vh - 150px); gap: 10px; }
        .game-area { flex-grow: 3; display: flex; flex-direction: column; background-color: #e0e0e0; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; }
        #gameCanvas { width: 100%; height: calc(100% - 60px); background-color: #2a8c3e; border: 2px solid white; box-sizing: border-box; display: block; }
        .match-info { display: flex; justify-content: space-around; align-items: center; padding: 10px 0; font-size: 1.2em; font-weight: bold; background-color: #f8f8f8; border-radius: 5px; margin-bottom: 10px; }
        .team-name { flex: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0 10px; min-width: 100px; } /* Added min-width */
        .score { padding: 0 20px; }
        .game-time { min-width: 80px; text-align: center; }
        .sidebar { flex-grow: 1; background-color: #ffffff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow-y: auto; display: flex; flex-direction: column; min-width: 200px; }
        .sidebar h3 { margin-top: 0; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 15px; }
        .stats-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .stats-table th, .stats-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .stats-table th { background-color: #f2f2f2; }
        .stats-table .stat-label { text-align: left; font-weight: bold; }
        .chat-betting-area { width: 95%; max-width: 1400px; height: 120px; display: flex; gap: 10px; margin-top: 10px; }
        .chat-container { flex-grow: 2; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; }
        .chat-box { flex-grow: 1; border: 1px solid #ccc; margin-bottom: 5px; padding: 5px; overflow-y: scroll; font-size: 0.9em; background-color: #f9f9f9; height: 60px; }
        .chat-input { display: flex; }
        .chat-input input { flex-grow: 1; padding: 5px; border: 1px solid #ccc; border-radius: 3px; }
        .chat-input button { padding: 5px 10px; margin-left: 5px; cursor: pointer; border: none; background-color: #4CAF50; color: white; border-radius: 3px; }
        .chat-input button:hover { background-color: #45a049; }
        .betting-container { flex-grow: 1; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: space-between; min-width: 250px; }
        .balance { text-align: center; font-weight: bold; margin-bottom: 5px; }
        .betting-controls { display: flex; flex-direction: column; gap: 5px; }
        .bet-options { display: flex; justify-content: space-around; font-size: 0.9em; margin-bottom: 5px; }
        .bet-team { font-weight: bold; }
        .bet-odds { color: #555; }
        .bet-input-area { display: flex; gap: 5px; }
        .bet-input-area input { width: 60px; padding: 4px; border: 1px solid #ccc; border-radius: 3px; }
        .bet-input-area button { padding: 4px 8px; cursor: pointer; border: none; color: white; border-radius: 3px; font-size: 0.9em; flex-grow: 1; }
        .bet-button-a { background-color: #2196F3; }
        .bet-button-a:hover { background-color: #1e88e5; }
        .bet-button-b { background-color: #f44336; }
        .bet-button-b:hover { background-color: #e53935; }
        button:disabled { background-color: #ccc !important; cursor: not-allowed !important; } /* More specific disabled style */
        .bet-message { font-size: 0.8em; color: green; text-align: center; min-height: 1.2em; margin-top: 5px; }
        .bet-error { color: red; }
        #nicknameModal { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: white; padding: 30px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content label { display: block; margin-bottom: 10px; font-size: 1.1em; }
        .modal-content input { padding: 8px; margin-bottom: 15px; width: 200px; border: 1px solid #ccc; border-radius: 4px; }
        .modal-content button { padding: 10px 20px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 1em; }
        .modal-content button:hover { background-color: #45a049; }
        .halftime-overlay, .fulltime-overlay, .initial-wait-overlay { position: absolute; top: 60px; /* Below match info */ left: 10px; right: 10px; bottom: 10px; height: calc(100% - 70px); width: calc(100% - 20px); background-color: rgba(0, 0, 0, 0.7); color: white; display: none; /* Initially hidden */ flex-direction: column; justify-content: center; align-items: center; font-size: 2em; text-align: center; z-index: 10; border-radius: 5px; box-sizing: border-box; }
        #connectionStatus {
            position: fixed;
            top: 5px;
            right: 10px;
            background-color: #ffc107;
            color: #333;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            z-index: 1001;
            transition: background-color 0.5s ease;
        }
        #connectionStatus.connected { background-color: #28a745; color: white; }
        #connectionStatus.error { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <div id="connectionStatus">Connecting...</div>

    <div id="nicknameModal">
         <div class="modal-content">
            <label for="nicknameInput">Enter Nickname (1-15 chars):</label>
            <input type="text" id="nicknameInput" maxlength="15">
            <button id="submitNickname">Join Interaction</button>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
             <div class="match-info">
                  <span id="teamANameEl" class="team-name">---</span>
                  <span class="score"><span id="scoreA">0</span> - <span id="scoreB">0</span></span>
                  <span id="teamBNameEl" class="team-name">---</span>
                  <span id="gameTimeEl" class="game-time">00:00</span>
             </div>
            <canvas id="gameCanvas"></canvas>
            <!-- Overlays -->
             <div id="initialWaitOverlay" class="initial-wait-overlay">
                Tournament Starting Soon!<br>
                Betting is Open!<br>
                <span id="initialTimerDisplay" style="font-size: 0.8em;"></span>
            </div>
             <div id="halftimeOverlay" class="halftime-overlay">
                Halftime<br>
                <span id="breakTimerDisplay"></span>
            </div>
             <div id="fulltimeOverlay" class="fulltime-overlay">
                Full Time!<br>
                Next match starting soon...<br>
                Betting Open!<br>
                 <span id="nextMatchTimerDisplay"></span>
            </div>
        </div>

        <div class="sidebar">
             <h3>Live Statistics</h3>
             <table class="stats-table">
                 <thead><tr><th>Stat</th><th id="statsTeamAHeader">A</th><th id="statsTeamBHeader">B</th></tr></thead>
                 <tbody>
                     <tr><td class="stat-label">Possession</td><td id="possessionA">--%</td><td id="possessionB">--%</td></tr>
                     <tr><td class="stat-label">Goals</td><td id="goalsA">0</td><td id="goalsB">0</td></tr>
                     <tr><td class="stat-label">Shots</td><td id="shotsA">0</td><td id="shotsB">0</td></tr>
                      <tr><td class="stat-label">Passes</td><td id="passesA">0</td><td id="passesB">0</td></tr>
                 </tbody>
             </table>
             <h3>Tournament Teams</h3>
             <ul id="teamListEl" style="font-size: 0.8em; padding-left: 20px; margin-bottom: 20px; list-style: decimal;">
                 <!-- Server could populate this eventually -->
             </ul>
             <div id="gameStatusMessageEl" style="text-align: center; margin-top: auto; font-style: italic; padding-top: 10px;">Connecting to simulation...</div>
        </div>
    </div>

    <div class="chat-betting-area">
        <div class="chat-container">
             <div id="chatBoxEl" class="chat-box">Welcome! Connecting to chat...</div>
             <div class="chat-input">
                 <input type="text" id="chatInputEl" placeholder="Enter nickname to type..." maxlength="100" disabled>
                 <button id="sendChatBtn" disabled>Send</button>
             </div>
         </div>
         <div class="betting-container">
             <div class="balance">Balance: $<span id="userBalanceEl">---</span></div>
              <div id="bettingControls" class="betting-controls">
                  <div class="bet-options"><div><span class="bet-team" id="betTeamANameEl">Team A</span>: <span class="bet-odds" id="oddsAEl">?.??</span></div><div><span class="bet-team" id="betTeamBNameEl">Team B</span>: <span class="bet-odds" id="oddsBEl">?.??</span></div></div>
                  <div class="bet-input-area"><input type="number" id="betAmountInputEl" min="1" step="1" placeholder="Amt" disabled><button id="betButtonAEl" class="bet-button bet-button-a" disabled>Bet A</button><button id="betButtonBEl" class="bet-button bet-button-b" disabled>Bet B</button></div>
                  <div id="betMessageEl" class="bet-message">Enter nickname to enable betting.</div>
              </div>
         </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const teamANameEl = document.getElementById('teamANameEl');
        const teamBNameEl = document.getElementById('teamBNameEl');
        const scoreAEl = document.getElementById('scoreA');
        const scoreBEl = document.getElementById('scoreB');
        const gameTimeEl = document.getElementById('gameTimeEl');
        const statsTeamAHeaderEl = document.getElementById('statsTeamAHeader');
        const statsTeamBHeaderEl = document.getElementById('statsTeamBHeader');
        const possessionAEl = document.getElementById('possessionA');
        const possessionBEl = document.getElementById('possessionB');
        const goalsAEl = document.getElementById('goalsA');
        const goalsBEl = document.getElementById('goalsB');
        const shotsAEl = document.getElementById('shotsA');
        const shotsBEl = document.getElementById('shotsB');
        const passesAEl = document.getElementById('passesA');
        const passesBEl = document.getElementById('passesB');
        const teamListEl = document.getElementById('teamListEl');
        const gameStatusMessageEl = document.getElementById('gameStatusMessageEl');
        const chatBoxEl = document.getElementById('chatBoxEl');
        const chatInputEl = document.getElementById('chatInputEl');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const userBalanceEl = document.getElementById('userBalanceEl');
        const betTeamANameEl = document.getElementById('betTeamANameEl');
        const betTeamBNameEl = document.getElementById('betTeamBNameEl');
        const oddsAEl = document.getElementById('oddsAEl');
        const oddsBEl = document.getElementById('oddsBEl');
        const betAmountInputEl = document.getElementById('betAmountInputEl');
        const betButtonAEl = document.getElementById('betButtonAEl');
        const betButtonBEl = document.getElementById('betButtonBEl');
        const betMessageEl = document.getElementById('betMessageEl');
        const nicknameModalEl = document.getElementById('nicknameModal');
        const nicknameInputEl = document.getElementById('nicknameInput');
        const submitNicknameBtn = document.getElementById('submitNickname');
        const halftimeOverlayEl = document.getElementById('halftimeOverlay');
        const fulltimeOverlayEl = document.getElementById('fulltimeOverlay');
        const initialWaitOverlayEl = document.getElementById('initialWaitOverlay');
        const breakTimerDisplayEl = document.getElementById('breakTimerDisplay');
        const nextMatchTimerDisplayEl = document.getElementById('nextMatchTimerDisplay');
        const initialTimerDisplayEl = document.getElementById('initialTimerDisplay');
        const connectionStatusEl = document.getElementById('connectionStatus');

        // --- Client State ---
        let players = [];
        let ball = { x: 0, y: 0, vx: 0, vy: 0, ownerId: null };
        let currentGameState = 'INITIALIZING'; // Local reflection of server state
        let userNickname = null;
        let userBalance = 0;
        let currentBet = null; // { team: 'A'/'B', amount: number } - Local reflection
        let breakEndTime = null;
        let breakTimerInterval = null;
        let animationFrameId = null;
        let socket = null;
        let serverTeamA = null; // Store full team object if needed
        let serverTeamB = null;

        // --- Constants (Client-side, mostly for drawing) ---
        const FIELD_WIDTH = 1050; const FIELD_HEIGHT = 680; const PLAYER_RADIUS = 10; const BALL_RADIUS = 5; const GOAL_WIDTH = 120; const GOAL_DEPTH = 20; const CENTER_CIRCLE_RADIUS = 91.5;

        // --- WebSocket Connection ---
        function connectWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log("Connecting WebSocket to:", wsUrl);

            connectionStatusEl.textContent = 'Connecting...';
            connectionStatusEl.className = '';

            // Cleanup old socket if reconnecting
            if (socket && socket.readyState !== WebSocket.CLOSED) {
                socket.close();
            }

            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                console.log('WebSocket connection established.');
                connectionStatusEl.textContent = 'Connected';
                connectionStatusEl.className = 'connected';
                gameStatusMessageEl.textContent = "Connected. Waiting for game state...";
                // Modal stays until nickname submitted
            };

            socket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    // console.log('Msg from server:', data.type, data.payload); // Debug: Log incoming messages
                    handleServerMessage(data);
                } catch (error) {
                    console.error('Failed to parse message or invalid JSON:', event.data, error);
                    addChatMessage("System", "Received invalid data from server.");
                }
            };

            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                connectionStatusEl.textContent = 'Connection Error';
                connectionStatusEl.className = 'error';
                gameStatusMessageEl.textContent = "Connection error. Please refresh.";
                disableInteraction("Connection Error");
                stopRendering();
                clearTimeout(breakTimerInterval);
                hideOverlays();
            };

            socket.onclose = (event) => {
                console.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'N/A'}`);
                connectionStatusEl.textContent = 'Disconnected';
                connectionStatusEl.className = 'error';
                gameStatusMessageEl.textContent = "Disconnected. Attempting to reconnect...";
                disableInteraction("Disconnected");
                stopRendering();
                clearTimeout(breakTimerInterval);
                hideOverlays();
                // Attempt to reconnect after a delay
                setTimeout(connectWebSocket, 5000); // Reconnect after 5 seconds
            };
        }

        function sendMessage(type, payload) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const message = JSON.stringify({ type, payload });
                socket.send(message);
            } else {
                console.error("WebSocket is not open. Cannot send message:", type);
                addChatMessage("System", "Error: Cannot send message - not connected.");
            }
        }

        // --- Message Handling ---
        function handleServerMessage(data) {
            const { type, payload } = data;

            switch (type) {
                case 'currentGameState': // Sent on initial connect or after major change
                    console.log("Received full game state:", payload.gameState);
                    updateCoreGameState(payload); // Update everything based on payload
                    updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || [];
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2, vx: 0, vy: 0, ownerId: null };
                    currentGameState = payload.gameState;
                    // Update stats display if available
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    handleGameStateChange(currentGameState, payload); // Set overlays/timers correctly
                    // Don't enable interaction yet, wait for 'welcome'
                    checkBettingStatus(); // Re-evaluate betting state based on new game state
                    break;

                case 'initialWait': // Server started the initial countdown
                    console.log("Handling initialWait");
                    updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                    updateScoreAndTime(0, 0, 0); // Reset score/time display
                    currentGameState = 'INITIAL_BETTING';
                    players = []; ball = { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 }; // Clear field
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus();
                    break;

                case 'matchStart':
                     console.log("Handling matchStart");
                     updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                     updateScoreAndTime(0, 0, 0);
                     currentGameState = 'FIRST_HALF';
                     handleGameStateChange(currentGameState, payload);
                     checkBettingStatus(); // Betting should be closed now
                    break;

                case 'gameStateUpdate': // Regular update during match
                    // Update only dynamic elements
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || []; // Update local player data
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 }; // Update local ball data
                    // currentGameState = payload.gameState; // Server might not send this in frequent updates, rely on event messages for state change
                     if(payload.stats) { updateStatsUI(payload.stats); }
                     // No overlay change here, just data update
                    break;

                case 'goalScored':
                    console.log("Handling goalScored");
                    updateScoreAndTime(payload.scoreA, payload.scoreB); // Update score immediately
                    addChatMessage("System", `⚽ GOAL! ${payload.scoringTeam === 'A' ? teamANameEl.textContent : teamBNameEl.textContent} scores! (${payload.scoreA}-${payload.scoreB})`);
                    // Update stats table goals
                    goalsAEl.textContent = payload.scoreA;
                    goalsBEl.textContent = payload.scoreB;
                    // Visual flash (optional)
                    canvas.style.transition = 'none';
                    canvas.style.backgroundColor = '#FFF';
                    setTimeout(() => {
                        canvas.style.transition = 'background-color 0.5s ease';
                        canvas.style.backgroundColor = '#2a8c3e';
                    }, 100);
                    break;

                case 'halfTime':
                     console.log("Handling halfTime");
                     updateScoreAndTime(payload.scoreA, payload.scoreB, 45 * 60);
                     currentGameState = 'HALF_TIME';
                     handleGameStateChange(currentGameState, payload);
                     checkBettingStatus(); // Betting closed
                     break;

                case 'secondHalfStart':
                    console.log("Handling secondHalfStart");
                    currentGameState = 'SECOND_HALF';
                    handleGameStateChange(currentGameState, payload); // Hide overlay
                    checkBettingStatus(); // Betting closed
                    break;

                case 'fullTime':
                     console.log("Handling fullTime");
                     updateScoreAndTime(payload.scoreA, payload.scoreB, 90 * 60);
                     currentGameState = 'FULL_TIME';
                     handleGameStateChange(currentGameState, payload); // Show overlay, start timer
                     currentBet = null; // Match ended, clear local bet state (server handles resolution)
                     checkBettingStatus(); // Betting should open for next match
                    break;

                 case 'welcome': // Server confirms nickname
                    console.log("Handling welcome");
                    userNickname = payload.nickname;
                    userBalance = payload.balance;
                    currentBet = payload.currentBet; // Restore any existing bet state from server
                    nicknameModalEl.style.display = 'none';
                    chatInputEl.disabled = false;
                    sendChatBtn.disabled = false;
                    chatInputEl.placeholder = "Type message...";
                    userBalanceEl.textContent = userBalance.toFixed(2);
                    addChatMessage("System", `Welcome, ${userNickname}! Your balance is $${userBalance.toFixed(2)}.`);
                    checkBettingStatus(); // Now check if betting should be enabled based on current game state
                    break;

                case 'chatBroadcast':
                    addChatMessage(payload.sender, payload.message);
                    break;

                case 'betResult':
                    console.log("Handling betResult", payload);
                    setBetMessage(payload.message, !payload.success);
                    if (payload.newBalance !== undefined) {
                        userBalance = payload.newBalance;
                        userBalanceEl.textContent = userBalance.toFixed(2);
                    }
                    // If bet failed because it was already placed, don't clear local state
                    if (payload.message !== 'Bet already placed.') {
                         // If successful, or refunded, or failed for other reasons (e.g. insufficient funds), clear local state
                         // as the server resolved/rejected it definitively.
                         currentBet = null;
                    }
                    // Re-evaluate betting buttons based on new state (e.g., if bet failed, maybe can bet again)
                    checkBettingStatus();
                    break;

                 case 'systemMessage':
                    addChatMessage("System", payload.message);
                    if (payload.isError) {
                         setBetMessage(payload.message, true); // Show error in bet area too
                    }
                    break;

                default:
                    console.warn('Unknown message type received:', type);
            }
        }

         // --- UI Update Functions ---
         function updateCoreGameState(payload) {
             // Used by 'currentGameState' to set everything initially
             serverTeamA = payload.teamA; // Store full team objects
             serverTeamB = payload.teamB;
             // Any other core state elements can be set here
         }

        function updateTeamUI(teamA, teamB, oddsAVal, oddsBVal) {
            teamANameEl.textContent = teamA?.name || '---';
            teamBNameEl.textContent = teamB?.name || '---';
            betTeamANameEl.textContent = teamA?.name || 'Team A';
            betTeamBNameEl.textContent = teamB?.name || 'Team B';
            statsTeamAHeaderEl.textContent = getPlayerInitials(teamA?.name || 'A');
            statsTeamBHeaderEl.textContent = getPlayerInitials(teamB?.name || 'B');
            oddsAEl.textContent = parseFloat(oddsAVal || 0).toFixed(2);
            oddsBEl.textContent = parseFloat(oddsBVal || 0).toFixed(2);
        }

        function updateScoreAndTime(sA, sB, timeS) {
            scoreAEl.textContent = sA ?? scoreAEl.textContent;
            scoreBEl.textContent = sB ?? scoreBEl.textContent;
            // Update stats table goals as well
            goalsAEl.textContent = sA ?? goalsAEl.textContent;
            goalsBEl.textContent = sB ?? goalsBEl.textContent;
            if (timeS !== undefined && timeS !== null) {
                 gameTimeEl.textContent = formatTime(timeS);
            }
        }

         function updateStatsUI(statsData) {
            // Simplified - assumes server sends { teamA: {shots, passes, goals}, teamB: {...} }
            // More complex stats like possession would need calculation or server provision
            if (!statsData) return;
            if(statsData.teamA) {
                shotsAEl.textContent = statsData.teamA.shots ?? shotsAEl.textContent;
                passesAEl.textContent = statsData.teamA.passes ?? passesAEl.textContent;
                goalsAEl.textContent = statsData.teamA.goals ?? goalsAEl.textContent; // Redundant with score update, but safe
            }
            if(statsData.teamB) {
                shotsBEl.textContent = statsData.teamB.shots ?? shotsBEl.textContent;
                passesBEl.textContent = statsData.teamB.passes ?? passesBEl.textContent;
                goalsBEl.textContent = statsData.teamB.goals ?? goalsBEl.textContent;
            }
            // Basic possession estimation (example - needs real data from server ideally)
            const totalPasses = (statsData.teamA?.passes || 0) + (statsData.teamB?.passes || 0);
            if (totalPasses > 0) {
                possessionAEl.textContent = Math.round(((statsData.teamA?.passes || 0) / totalPasses) * 100) + '%';
                possessionBEl.textContent = Math.round(((statsData.teamB?.passes || 0) / totalPasses) * 100) + '%';
            } else {
                 possessionAEl.textContent = '--%';
                 possessionBEl.textContent = '--%';
            }
         }


        function hideOverlays() {
            initialWaitOverlayEl.style.display = 'none';
            halftimeOverlayEl.style.display = 'none';
            fulltimeOverlayEl.style.display = 'none';
        }

        function handleGameStateChange(newState, payload) {
            hideOverlays();
            clearTimeout(breakTimerInterval); // Stop previous timers

            currentGameState = newState; // Update local tracker

            let statusText = "";
            breakEndTime = payload?.breakEndTime; // Update break time from payload if present

            switch (newState) {
                case 'INITIALIZING':
                     statusText = "Connecting...";
                    break;
                case 'INITIAL_BETTING':
                    initialWaitOverlayEl.style.display = 'flex';
                    statusText = `Tournament Starting Soon! Betting open...`;
                    if (breakEndTime) startBreakTimer(initialTimerDisplayEl, "First match starts in: ");
                    break;
                case 'PRE_MATCH':
                     statusText = `Preparing Next Match: ${teamANameEl.textContent} vs ${teamBNameEl.textContent}. Betting Open!`;
                     // Overlay is hidden, betting handled by checkBettingStatus
                    break;
                case 'FIRST_HALF':
                    statusText = `Match Running: ${teamANameEl.textContent} vs ${teamBNameEl.textContent} (1st Half)`;
                    break;
                case 'HALF_TIME':
                    halftimeOverlayEl.style.display = 'flex';
                    statusText = `Half Time: ${teamANameEl.textContent} ${scoreAEl.textContent}-${scoreBEl.textContent} ${teamBNameEl.textContent}`;
                    if (breakEndTime) startBreakTimer(breakTimerDisplayEl, "2nd Half starts in: ");
                    break;
                case 'SECOND_HALF':
                     statusText = `Match Running: ${teamANameEl.textContent} vs ${teamBNameEl.textContent} (2nd Half)`;
                    break;
                case 'FULL_TIME':
                     fulltimeOverlayEl.style.display = 'flex';
                     statusText = `Full Time: ${teamANameEl.textContent} ${scoreAEl.textContent}-${scoreBEl.textContent} ${teamBNameEl.textContent}. Betting open for next match!`;
                     if (breakEndTime) startBreakTimer(nextMatchTimerDisplayEl, "Next match starts in: ");
                    break;
                 case 'BETWEEN_GAMES': // Server might use this briefly
                    statusText = `Preparing Next Match... Betting Open!`;
                    break;
                 default:
                    statusText = "Waiting for server update...";
            }
            gameStatusMessageEl.textContent = statusText;
        }

        function startBreakTimer(displayElement, prefix) {
            clearTimeout(breakTimerInterval);

            const updateTimer = () => {
                if (!breakEndTime) { // Stop if breakEndTime becomes null (e.g., state changed)
                     displayElement.textContent = prefix + "00:00";
                    return;
                }
                const now = Date.now();
                const timeLeftS = Math.max(0, Math.floor((breakEndTime - now) / 1000));
                const mins = Math.floor(timeLeftS / 60);
                const secs = timeLeftS % 60;
                displayElement.textContent = `${prefix}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;

                if (timeLeftS > 0) {
                    // Adjust timeout interval slightly to align better with seconds boundary
                    const msToNextSecond = 1000 - (Date.now() % 1000);
                    breakTimerInterval = setTimeout(updateTimer, msToNextSecond);
                } else {
                    // Timer finished naturally
                    displayElement.textContent = prefix + "00:00";
                    // Overlays should be hidden by subsequent game state messages from server
                }
            };
            updateTimer(); // Start immediately
        }

        // --- Drawing Functions ---
        function drawField() { ctx.fillStyle = '#2a8c3e'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, CENTER_CIRCLE_RADIUS * (canvas.width / FIELD_WIDTH), 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 5 * (canvas.width / FIELD_WIDTH) , 0, Math.PI*2); ctx.fill(); const goalDrawWidth = GOAL_WIDTH * (canvas.height / FIELD_HEIGHT); const goalDrawDepth = GOAL_DEPTH * (canvas.width / FIELD_WIDTH); ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; ctx.fillRect(0, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.fillRect(canvas.width - goalDrawDepth, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; const penaltyAreaWidth = 165 * (canvas.width / FIELD_WIDTH); const penaltyAreaHeight = 403 * (canvas.height / FIELD_HEIGHT); ctx.strokeRect(0, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); ctx.strokeRect(canvas.width - penaltyAreaWidth, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); }
        function drawPlayer(player) {
            const canvasX = player.x * (canvas.width / FIELD_WIDTH);
            const canvasY = player.y * (canvas.height / FIELD_HEIGHT);
            const canvasRadius = PLAYER_RADIUS * (canvas.width / FIELD_WIDTH);
            // Player Circle
            ctx.fillStyle = player.color || '#CCCCCC'; // Default color if missing
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, canvasRadius, 0, Math.PI * 2);
            ctx.fill();
            // Outline
            ctx.strokeStyle = ball.ownerId === player.id ? '#FFFF00' : '#000000'; // Highlight if has ball
            ctx.lineWidth = ball.ownerId === player.id ? 2 : 1;
            ctx.stroke();
             // Initials Inside Circle
             ctx.fillStyle = player.textColor || '#000000'; // Use provided textColor
             ctx.font = `bold ${canvasRadius * 0.8}px sans-serif`; // Slightly smaller font
             ctx.textAlign = 'center';
             ctx.textBaseline = 'middle';
             ctx.fillText(player.initials || 'P?', canvasX, canvasY);
             // Player Name Below (Optional - can clutter)
             // ctx.fillStyle = '#333';
             // ctx.font = `${canvasRadius * 0.6}px sans-serif`;
             // ctx.textAlign = 'center';
             // ctx.textBaseline = 'top'; // Position below circle
             // ctx.fillText(player.name || 'Unknown', canvasX, canvasY + canvasRadius + 2);
        }
        function drawBall() {
            const canvasX = ball.x * (canvas.width / FIELD_WIDTH);
            const canvasY = ball.y * (canvas.height / FIELD_HEIGHT);
            const canvasRadius = BALL_RADIUS * (canvas.width / FIELD_WIDTH);
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(canvasX, canvasY, Math.max(2, canvasRadius), 0, Math.PI * 2); // Ensure minimum visible size
            ctx.fill();
            ctx.stroke();
        }
        function drawGame() {
            // Ensure canvas dimensions match CSS dimensions for correct scaling
             const currentWidth = canvas.clientWidth;
             const currentHeight = canvas.clientHeight;
            if (canvas.width !== currentWidth || canvas.height !== currentHeight) {
                canvas.width = currentWidth;
                canvas.height = currentHeight;
                 console.log("Canvas resized to:", canvas.width, canvas.height);
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawField();

            if (players && players.length > 0) {
                players.forEach(drawPlayer);
            }
             // Always draw the ball, even if players aren't present yet
            if (ball) {
                 drawBall();
            }
        }

        // --- Client Rendering Loop ---
        function mainLoop() {
            drawGame(); // Draw based on latest received state (players, ball)
            animationFrameId = requestAnimationFrame(mainLoop);
        }
        function startRendering() { if (!animationFrameId) { animationFrameId = requestAnimationFrame(mainLoop); } }
        function stopRendering() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Utility Functions (Client-side) ---
        function formatTime(ingameSeconds) { const totalSeconds = Math.max(0, Math.floor(ingameSeconds)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function addChatMessage(sender, message) { const messageEl = document.createElement('div'); // Sanitize sender and message - basic example
             const safeSender = sender.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); messageEl.innerHTML = `<strong>${safeSender}:</strong> ${safeMessage}`; chatBoxEl.appendChild(messageEl); chatBoxEl.scrollTop = chatBoxEl.scrollHeight; }
        function setBetMessage(message, isError = false) { betMessageEl.textContent = message; betMessageEl.className = `bet-message ${isError ? 'bet-error' : ''}`; }
        function getPlayerInitials(name) { if (!name || typeof name !== 'string') return '??'; const parts = name.trim().split(' '); if (parts.length >= 2) { return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase(); } else if (parts.length === 1 && name.length > 0) { return name.substring(0, Math.min(2, name.length)).toUpperCase(); } return '??'; }

        function disableInteraction(reason = "Disabled") {
            chatInputEl.disabled = true;
            sendChatBtn.disabled = true;
            chatInputEl.placeholder = reason;
            disableBetting(reason); // Use the betting disable function
        }
         function disableBetting(message) {
             betAmountInputEl.disabled = true;
             betButtonAEl.disabled = true;
             betButtonBEl.disabled = true;
             setBetMessage(message, true); // Show the reason as an error/status
         }

        function checkBettingStatus() {
             const isBettingPeriod = (
                 currentGameState === 'INITIAL_BETTING' ||
                 currentGameState === 'FULL_TIME' ||
                 currentGameState === 'PRE_MATCH' || // Added PRE_MATCH
                 currentGameState === 'BETWEEN_GAMES'
             );

            if (!userNickname) {
                disableBetting("Enter nickname to bet.");
                return;
            }

             if (currentBet) {
                 const betOnTeamName = currentBet.team === 'A' ? (betTeamANameEl.textContent || 'Team A') : (betTeamBNameEl.textContent || 'Team B');
                 disableBetting(`Bet placed: $${currentBet.amount} on ${betOnTeamName}.`);
                 return;
             }

             if (userBalance <= 0) {
                 disableBetting("Balance is $0.00. Cannot place bets.");
                 return;
             }

             if (isBettingPeriod) {
                 betButtonAEl.disabled = false;
                 betButtonBEl.disabled = false;
                 betAmountInputEl.disabled = false;
                 setBetMessage("Betting is open!", false); // Not an error
             } else {
                 disableBetting("Betting is closed.");
             }
         }


        // --- Initialization (Client-side) ---
        function init() {
            console.log("Client initializing...");
            connectWebSocket(); // Establish WebSocket connection

             // Setup button listeners
             submitNicknameBtn.addEventListener('click', () => {
                 const nick = nicknameInputEl.value.trim();
                 if (nick && nick.length > 0 && nick.length <= 15) {
                     sendMessage('setNickname', nick);
                 } else {
                     alert("Please enter a valid nickname (1-15 characters).");
                 }
             });
             nicknameInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitNicknameBtn.click(); });

             sendChatBtn.addEventListener('click', () => {
                 const message = chatInputEl.value.trim();
                 if (message) {
                     sendMessage('chatMessage', message);
                     chatInputEl.value = '';
                 }
             });
             chatInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !sendChatBtn.disabled) sendChatBtn.click(); });

             betButtonAEl.addEventListener('click', () => {
                 const amount = parseInt(betAmountInputEl.value, 10);
                 if (!isNaN(amount) && amount > 0) {
                     disableBetting("Placing bet..."); // Disable immediately
                     sendMessage('placeBet', { team: 'A', amount: amount });
                 } else {
                     setBetMessage("Invalid bet amount.", true);
                 }
             });
             betButtonBEl.addEventListener('click', () => {
                  const amount = parseInt(betAmountInputEl.value, 10);
                 if (!isNaN(amount) && amount > 0) {
                      disableBetting("Placing bet..."); // Disable immediately
                     sendMessage('placeBet', { team: 'B', amount: amount });
                 } else {
                      setBetMessage("Invalid bet amount.", true);
                 }
             });

             // Initial UI state
             disableInteraction("Connecting...");
             userBalanceEl.textContent = '---';

            // Draw the static field initially (will resize on first drawGame)
            drawField();

            startRendering();
            console.log("Client init complete.");
        }

        window.onload = init;

    </script>
</body>
</html>