<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Tournament Sim</title>
    <style>
        /* Basic Reset & Font */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; color: #333; height: 100vh; overflow: hidden; padding-top: 5px; /* Space for connection status */ }

        /* Layout Containers */
        .container { display: flex; width: 95%; max-width: 1400px; margin-top: 10px; height: calc(100vh - 150px - 5px); /* Adjust for body padding */ gap: 10px; }
        .game-area { flex-grow: 3; display: flex; flex-direction: column; background-color: #e0e0e0; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; min-width: 400px; /* Prevent excessive shrinking */ }
        .sidebar { flex-grow: 1; background-color: #ffffff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow-y: auto; display: flex; flex-direction: column; min-width: 220px; /* Ensure sidebar readable */ max-width: 300px; }
        .chat-betting-area { width: 95%; max-width: 1400px; height: 120px; display: flex; gap: 10px; margin-top: 10px; }

        /* Game Area Components */
        #gameCanvas { width: 100%; height: calc(100% - 60px); background-color: #2a8c3e; border: 2px solid white; display: block; transition: background-color 0.5s ease; /* For goal flash */ }
        .match-info { display: flex; justify-content: space-around; align-items: center; padding: 10px 0; font-size: 1.2em; font-weight: bold; background-color: #f8f8f8; border-radius: 5px; margin-bottom: 10px; }
        .team-name { flex: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0 10px; min-width: 100px; }
        .score { padding: 0 20px; font-size: 1.3em; }
        .game-time { min-width: 80px; text-align: center; font-variant-numeric: tabular-nums; }

        /* Overlays */
        .halftime-overlay, .fulltime-overlay, .initial-wait-overlay { position: absolute; top: 60px; left: 10px; right: 10px; bottom: 10px; height: calc(100% - 70px); width: calc(100% - 20px); background-color: rgba(0, 0, 0, 0.75); color: white; display: none; /* Hidden by default */ flex-direction: column; justify-content: center; align-items: center; font-size: 2.2em; text-align: center; z-index: 10; border-radius: 5px; box-sizing: border-box; padding: 20px; }
        .initial-wait-overlay span, .halftime-overlay span, .fulltime-overlay span { font-size: 0.7em; margin-top: 15px; font-weight: normal; }

        /* Sidebar Components */
        .sidebar h3 { margin-top: 0; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 15px; font-size: 1.1em; }
        .stats-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .stats-table th, .stats-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .stats-table th { background-color: #f2f2f2; font-weight: bold; }
        .stats-table .stat-label { text-align: left; font-weight: bold; padding-left: 8px; }
        #teamListEl { font-size: 0.85em; padding-left: 25px; margin-bottom: 20px; list-style: decimal; max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding-top: 5px; padding-bottom: 5px; border-radius: 4px;}
        #teamListEl li { margin-bottom: 3px;}
        #gameStatusMessageEl { text-align: center; margin-top: auto; font-style: italic; padding-top: 15px; border-top: 1px solid #eee; font-size: 0.9em; color: #555; }

        /* Chat/Betting Area */
        .chat-container { flex-grow: 2; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; min-width: 300px; }
        .chat-box { flex-grow: 1; border: 1px solid #ccc; margin-bottom: 5px; padding: 8px; overflow-y: scroll; font-size: 0.9em; background-color: #f9f9f9; height: 60px; line-height: 1.4; }
        .chat-box div { margin-bottom: 4px; word-wrap: break-word; }
        .chat-box strong { color: #0056b3; } /* Make sender name stand out */
        .chat-input { display: flex; }
        .chat-input input { flex-grow: 1; padding: 6px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; }
        .chat-input button { padding: 6px 12px; margin-left: 5px; cursor: pointer; border: none; background-color: #4CAF50; color: white; border-radius: 3px; transition: background-color 0.2s; }
        .chat-input button:hover:not(:disabled) { background-color: #45a049; }

        .betting-container { flex-grow: 1; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: space-between; min-width: 280px; }
        .balance { text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 1.1em; }
        .betting-controls { display: flex; flex-direction: column; gap: 6px; }
        .bet-options { display: flex; justify-content: space-around; font-size: 0.95em; margin-bottom: 5px; }
        .bet-team { font-weight: bold; }
        .bet-odds { color: #007bff; font-weight: bold; }
        .bet-input-area { display: flex; gap: 5px; }
        .bet-input-area input { width: 70px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; text-align: right; }
        .bet-input-area button { padding: 5px 10px; cursor: pointer; border: none; color: white; border-radius: 3px; font-size: 0.9em; flex-grow: 1; transition: background-color 0.2s; }
        .bet-button-a { background-color: #2196F3; }
        .bet-button-a:hover:not(:disabled) { background-color: #1e88e5; }
        .bet-button-b { background-color: #f44336; }
        .bet-button-b:hover:not(:disabled) { background-color: #e53935; }
        button:disabled { background-color: #ccc !important; cursor: not-allowed !important; color: #666 !important; }
        .bet-message { font-size: 0.85em; color: green; text-align: center; min-height: 1.3em; margin-top: 5px; font-weight: bold; }
        .bet-error { color: red; }

        /* Nickname Modal */
        #nicknameModal { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: white; padding: 35px 40px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content label { display: block; margin-bottom: 12px; font-size: 1.15em; color: #333; }
        .modal-content input { padding: 9px 10px; margin-bottom: 18px; width: 220px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em;}
        .modal-content button { padding: 10px 25px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 1em; transition: background-color 0.2s; }
        .modal-content button:hover { background-color: #45a049; }

        /* Connection Status */
        #connectionStatus { position: fixed; top: 0; left: 0; width: 100%; background-color: #ffc107; color: #333; padding: 4px 0; text-align: center; font-size: 0.85em; z-index: 1001; transition: background-color 0.5s ease, color 0.5s ease; }
        #connectionStatus.connected { background-color: #28a745; color: white; }
        #connectionStatus.error { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <div id="connectionStatus">Connecting...</div>

    <div id="nicknameModal">
         <div class="modal-content">
            <label for="nicknameInput">Enter Nickname (1-15 chars):</label>
            <input type="text" id="nicknameInput" maxlength="15">
            <button id="submitNickname">Join Interaction</button>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
             <div class="match-info">
                  <span id="teamANameEl" class="team-name">---</span>
                  <span class="score"><span id="scoreA">0</span> - <span id="scoreB">0</span></span>
                  <span id="teamBNameEl" class="team-name">---</span>
                  <span id="gameTimeEl" class="game-time">00:00</span>
             </div>
            <canvas id="gameCanvas"></canvas>
            <!-- Overlays -->
             <div id="initialWaitOverlay" class="initial-wait-overlay">
                Tournament Starting Soon!
                <span></span> <!-- Timer placeholder -->
            </div>
             <div id="halftimeOverlay" class="halftime-overlay">
                Halftime
                <span></span> <!-- Timer placeholder -->
            </div>
             <div id="fulltimeOverlay" class="fulltime-overlay">
                Full Time!
                 <span></span> <!-- Timer placeholder -->
            </div>
        </div>

        <div class="sidebar">
             <h3>Live Statistics</h3>
             <table class="stats-table">
                 <thead><tr><th>Stat</th><th id="statsTeamAHeader">A</th><th id="statsTeamBHeader">B</th></tr></thead>
                 <tbody>
                     <tr><td class="stat-label">Possession</td><td id="possessionA">--%</td><td id="possessionB">--%</td></tr>
                     <tr><td class="stat-label">Goals</td><td id="goalsA">0</td><td id="goalsB">0</td></tr>
                     <tr><td class="stat-label">Shots</td><td id="shotsA">0</td><td id="shotsB">0</td></tr>
                      <tr><td class="stat-label">Passes</td><td id="passesA">0</td><td id="passesB">0</td></tr>
                 </tbody>
             </table>
             <h3>Tournament Teams</h3>
             <ul id="teamListEl">
                 <!-- Populated by JS -->
             </ul>
             <div id="gameStatusMessageEl">Connecting...</div>
        </div>
    </div>

    <div class="chat-betting-area">
        <div class="chat-container">
             <div id="chatBoxEl" class="chat-box">Welcome! Connecting...</div>
             <div class="chat-input">
                 <input type="text" id="chatInputEl" placeholder="Enter nickname to type..." maxlength="100" disabled>
                 <button id="sendChatBtn" disabled>Send</button>
             </div>
         </div>
         <div class="betting-container">
             <div class="balance">Balance: $<span id="userBalanceEl">---</span></div>
              <div id="bettingControls" class="betting-controls">
                  <div class="bet-options"><div><span class="bet-team" id="betTeamANameEl">Team A</span>: <span class="bet-odds" id="oddsAEl">?.??</span></div><div><span class="bet-team" id="betTeamBNameEl">Team B</span>: <span class="bet-odds" id="oddsBEl">?.??</span></div></div>
                  <div class="bet-input-area"><input type="number" id="betAmountInputEl" min="1" step="1" placeholder="Amt" disabled><button id="betButtonAEl" class="bet-button bet-button-a" disabled>Bet A</button><button id="betButtonBEl" class="bet-button bet-button-b" disabled>Bet B</button></div>
                  <div id="betMessageEl" class="bet-message">Enter nickname to enable betting.</div>
              </div>
         </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const teamANameEl = document.getElementById('teamANameEl');
        const teamBNameEl = document.getElementById('teamBNameEl');
        const scoreAEl = document.getElementById('scoreA');
        const scoreBEl = document.getElementById('scoreB');
        const gameTimeEl = document.getElementById('gameTimeEl');
        const statsTeamAHeaderEl = document.getElementById('statsTeamAHeader');
        const statsTeamBHeaderEl = document.getElementById('statsTeamBHeader');
        const possessionAEl = document.getElementById('possessionA');
        const possessionBEl = document.getElementById('possessionB');
        const goalsAEl = document.getElementById('goalsA');
        const goalsBEl = document.getElementById('goalsB');
        const shotsAEl = document.getElementById('shotsA');
        const shotsBEl = document.getElementById('shotsB');
        const passesAEl = document.getElementById('passesA');
        const passesBEl = document.getElementById('passesB');
        const teamListEl = document.getElementById('teamListEl');
        const gameStatusMessageEl = document.getElementById('gameStatusMessageEl');
        const chatBoxEl = document.getElementById('chatBoxEl');
        const chatInputEl = document.getElementById('chatInputEl');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const userBalanceEl = document.getElementById('userBalanceEl');
        const betTeamANameEl = document.getElementById('betTeamANameEl');
        const betTeamBNameEl = document.getElementById('betTeamBNameEl');
        const oddsAEl = document.getElementById('oddsAEl');
        const oddsBEl = document.getElementById('oddsBEl');
        const betAmountInputEl = document.getElementById('betAmountInputEl');
        const betButtonAEl = document.getElementById('betButtonAEl');
        const betButtonBEl = document.getElementById('betButtonBEl');
        const betMessageEl = document.getElementById('betMessageEl');
        const nicknameModalEl = document.getElementById('nicknameModal');
        const nicknameInputEl = document.getElementById('nicknameInput');
        const submitNicknameBtn = document.getElementById('submitNickname');
        const initialWaitOverlayEl = document.getElementById('initialWaitOverlay');
        const halftimeOverlayEl = document.getElementById('halftimeOverlay');
        const fulltimeOverlayEl = document.getElementById('fulltimeOverlay');
        // Get timer display elements from within overlays
        const initialTimerDisplayEl = initialWaitOverlayEl.querySelector('span');
        const breakTimerDisplayEl = halftimeOverlayEl.querySelector('span');
        const nextMatchTimerDisplayEl = fulltimeOverlayEl.querySelector('span');
        const connectionStatusEl = document.getElementById('connectionStatus');

        // --- Client State ---
        let players = [];
        let ball = { x: 0, y: 0, vx: 0, vy: 0, ownerId: null };
        let currentGameState = 'INITIALIZING';
        let userNickname = null;
        let userBalance = 0;
        let currentBet = null;
        let breakEndTime = null;
        let breakTimerInterval = null;
        let animationFrameId = null;
        let socket = null;
        let serverTeamA = null;
        let serverTeamB = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY_MS = 5000;

        // --- Constants ---
        const FIELD_WIDTH = 1050; const FIELD_HEIGHT = 680; const PLAYER_RADIUS = 10; const BALL_RADIUS = 5; const GOAL_WIDTH = 120; const GOAL_DEPTH = 20; const CENTER_CIRCLE_RADIUS = 91.5;

        // --- WebSocket Connection ---
        function connectWebSocket() {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                console.error("Max reconnection attempts reached. Please refresh the page.");
                connectionStatusEl.textContent = 'Connection Failed. Please Refresh.';
                connectionStatusEl.className = 'error';
                disableInteraction("Connection Failed");
                return;
            }

            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log(`Attempting WebSocket connection to: ${wsUrl} (Attempt ${reconnectAttempts + 1})`);

            connectionStatusEl.textContent = `Connecting... (Attempt ${reconnectAttempts + 1})`;
            connectionStatusEl.className = '';

            if (socket && socket.readyState !== WebSocket.CLOSED) { socket.close(); }

            socket = new WebSocket(wsUrl);

            socket.onopen = () => {
                console.log('WebSocket connection established.');
                connectionStatusEl.textContent = 'Connected';
                connectionStatusEl.className = 'connected';
                gameStatusMessageEl.textContent = "Connected. Waiting for game state...";
                reconnectAttempts = 0; // Reset attempts on successful connection
            };

            socket.onmessage = (event) => { handleServerMessage(event.data); }; // Pass data directly

            socket.onerror = (error) => {
                console.error('WebSocket error:', error);
                connectionStatusEl.textContent = 'Connection Error';
                connectionStatusEl.className = 'error';
                // Don't disable interaction immediately on error, wait for close
            };

            socket.onclose = (event) => {
                console.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'N/A'}`);
                connectionStatusEl.textContent = 'Disconnected. Retrying...';
                connectionStatusEl.className = 'error';
                gameStatusMessageEl.textContent = "Disconnected. Attempting to reconnect...";
                disableInteraction("Disconnected");
                stopRendering();
                clearTimeout(breakTimerInterval);
                hideOverlays();
                reconnectAttempts++;
                setTimeout(connectWebSocket, RECONNECT_DELAY_MS);
            };
        }

        function sendMessage(type, payload) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type, payload }));
            } else {
                console.error("WebSocket is not open. Cannot send message:", type);
                addChatMessage("System", "[Error: Cannot send message - not connected]");
            }
        }

        // --- Message Handling ---
        function handleServerMessage(jsonData) {
             let data;
             try {
                 data = JSON.parse(jsonData);
                // console.log('Msg from server:', data.type, data.payload); // Optional Debug
             } catch (error) {
                 console.error('Failed to parse message JSON:', jsonData, error);
                 addChatMessage("System", "[Received invalid data from server]");
                 return;
             }

            const { type, payload } = data;

            switch (type) {
                case 'currentGameState':
                    console.log("Received full game state:", payload.gameState);
                    updateCoreGameState(payload);
                    updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || [];
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2, vx: 0, vy: 0, ownerId: null };
                    currentGameState = payload.gameState;
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    if (payload.allTournamentTeams && Array.isArray(payload.allTournamentTeams)) {
                        populateTeamList(payload.allTournamentTeams);
                    }
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus(); // Crucial to check betting after state update
                    break;

                case 'initialWait':
                    console.log("Handling initialWait");
                    updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                    updateScoreAndTime(0, 0, 0);
                    currentGameState = 'INITIAL_BETTING';
                    players = []; ball = { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus();
                    break;

                case 'matchStart':
                     console.log("Handling matchStart");
                     updateTeamUI(payload.teamA, payload.teamB, payload.oddsA, payload.oddsB);
                     updateScoreAndTime(0, 0, 0);
                     currentGameState = 'FIRST_HALF';
                     handleGameStateChange(currentGameState, payload);
                     checkBettingStatus();
                    break;

                case 'gameStateUpdate':
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || [];
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    break;

                case 'goalScored':
                    console.log("Handling goalScored");
                    updateScoreAndTime(payload.scoreA, payload.scoreB);
                    addChatMessage("System", `âš½ GOAL! ${payload.scoringTeam === 'A' ? teamANameEl.textContent : teamBNameEl.textContent} scores! (${payload.scoreA}-${payload.scoreB})`);
                    goalsAEl.textContent = payload.scoreA; goalsBEl.textContent = payload.scoreB;
                    canvas.style.transition = 'none'; canvas.style.backgroundColor = '#FFF';
                    setTimeout(() => { canvas.style.transition = 'background-color 0.5s ease'; canvas.style.backgroundColor = '#2a8c3e'; }, 100);
                    break;

                case 'halfTime':
                     console.log("Handling halfTime");
                     updateScoreAndTime(payload.scoreA, payload.scoreB, 45 * 60);
                     currentGameState = 'HALF_TIME';
                     handleGameStateChange(currentGameState, payload);
                     checkBettingStatus();
                     break;

                case 'secondHalfStart':
                    console.log("Handling secondHalfStart");
                    currentGameState = 'SECOND_HALF';
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus();
                    break;

                case 'fullTime':
                     console.log("Handling fullTime");
                     updateScoreAndTime(payload.scoreA, payload.scoreB, 90 * 60);
                     currentGameState = 'FULL_TIME';
                     handleGameStateChange(currentGameState, payload);
                     currentBet = null; // Clear local bet state
                     checkBettingStatus();
                    break;

                 case 'welcome':
                    console.log("Handling welcome");
                    userNickname = payload.nickname; userBalance = payload.balance; currentBet = payload.currentBet;
                    nicknameModalEl.style.display = 'none';
                    chatInputEl.disabled = false; sendChatBtn.disabled = false; chatInputEl.placeholder = "Type message...";
                    userBalanceEl.textContent = userBalance.toFixed(2);
                    addChatMessage("System", `Welcome, ${userNickname}! Balance: $${userBalance.toFixed(2)}.`);
                    checkBettingStatus();
                    break;

                case 'chatBroadcast': addChatMessage(payload.sender, payload.message); break;
                case 'betResult':
                    console.log("Handling betResult", payload);
                    setBetMessage(payload.message, !payload.success);
                    if (payload.newBalance !== undefined) { userBalance = payload.newBalance; userBalanceEl.textContent = userBalance.toFixed(2); }
                    if (payload.message !== 'Bet already placed.') { currentBet = null; }
                    checkBettingStatus(); break;
                 case 'systemMessage': addChatMessage("System", `[Server: ${payload.message}]`); if (payload.isError) { setBetMessage(payload.message, true); } break;
                default: console.warn('Unknown message type received:', type); break;
            }
        }

         // --- UI Update Functions ---
         function updateCoreGameState(payload) { serverTeamA = payload.teamA; serverTeamB = payload.teamB; }
         function updateTeamUI(teamA, teamB, oddsAVal, oddsBVal) { teamANameEl.textContent = teamA?.name || '---'; teamBNameEl.textContent = teamB?.name || '---'; betTeamANameEl.textContent = teamA?.name || 'Team A'; betTeamBNameEl.textContent = teamB?.name || 'Team B'; statsTeamAHeaderEl.textContent = getPlayerInitials(teamA?.name || 'A'); statsTeamBHeaderEl.textContent = getPlayerInitials(teamB?.name || 'B'); oddsAEl.textContent = parseFloat(oddsAVal || 0).toFixed(2); oddsBEl.textContent = parseFloat(oddsBVal || 0).toFixed(2); }
         function updateScoreAndTime(sA, sB, timeS) { scoreAEl.textContent = sA ?? scoreAEl.textContent; scoreBEl.textContent = sB ?? scoreBEl.textContent; goalsAEl.textContent = sA ?? goalsAEl.textContent; goalsBEl.textContent = sB ?? goalsBEl.textContent; if (timeS !== undefined && timeS !== null) { gameTimeEl.textContent = formatTime(timeS); } }
         function updateStatsUI(statsData) { if (!statsData) return; if(statsData.teamA) { shotsAEl.textContent = statsData.teamA.shots ?? shotsAEl.textContent; passesAEl.textContent = statsData.teamA.passes ?? passesAEl.textContent; goalsAEl.textContent = statsData.teamA.goals ?? goalsAEl.textContent; } if(statsData.teamB) { shotsBEl.textContent = statsData.teamB.shots ?? shotsBEl.textContent; passesBEl.textContent = statsData.teamB.passes ?? passesBEl.textContent; goalsBEl.textContent = statsData.teamB.goals ?? goalsBEl.textContent; } const totalPasses = (statsData.teamA?.passes || 0) + (statsData.teamB?.passes || 0); if (totalPasses > 0) { possessionAEl.textContent = Math.round(((statsData.teamA?.passes || 0) / totalPasses) * 100) + '%'; possessionBEl.textContent = Math.round(((statsData.teamB?.passes || 0) / totalPasses) * 100) + '%'; } else { possessionAEl.textContent = '50%'; possessionBEl.textContent = '50%'; } }
         function populateTeamList(teamNames) { if (!teamListEl) return; teamListEl.innerHTML = ''; if (!teamNames || teamNames.length === 0) { teamListEl.innerHTML = '<li>Team list unavailable.</li>'; return; } teamNames.forEach(name => { const li = document.createElement('li'); li.textContent = name; teamListEl.appendChild(li); }); }

         // --- Game State Change & Timers ---
        function hideOverlays() { initialWaitOverlayEl.style.display = 'none'; halftimeOverlayEl.style.display = 'none'; fulltimeOverlayEl.style.display = 'none'; }
        function handleGameStateChange(newState, payload) {
            hideOverlays(); clearTimeout(breakTimerInterval);
            currentGameState = newState; breakEndTime = payload?.breakEndTime;
            let statusText = ""; let overlayTimerEl = null; let overlayPrefix = "";

            switch (newState) {
                case 'INITIALIZING': statusText = "Initializing..."; break;
                case 'INITIAL_BETTING': initialWaitOverlayEl.style.display = 'flex'; statusText = `Betting open for first match!`; overlayTimerEl = initialTimerDisplayEl; overlayPrefix = "Match starts in: "; break;
                case 'PRE_MATCH': statusText = `Preparing: ${teamANameEl.textContent} vs ${teamBNameEl.textContent}. Betting Open!`; break; // No overlay
                case 'FIRST_HALF': statusText = `Match Running: ${teamANameEl.textContent} vs ${teamBNameEl.textContent} (1st Half)`; break;
                case 'HALF_TIME': halftimeOverlayEl.style.display = 'flex'; statusText = `Half Time: ${teamANameEl.textContent} ${scoreAEl.textContent}-${scoreBEl.textContent} ${teamBNameEl.textContent}`; overlayTimerEl = breakTimerDisplayEl; overlayPrefix = "2nd Half starts in: "; break;
                case 'SECOND_HALF': statusText = `Match Running: ${teamANameEl.textContent} vs ${teamBNameEl.textContent} (2nd Half)`; break;
                case 'FULL_TIME': fulltimeOverlayEl.style.display = 'flex'; statusText = `Full Time: ${teamANameEl.textContent} ${scoreAEl.textContent}-${scoreBEl.textContent} ${teamBNameEl.textContent}. Betting open!`; overlayTimerEl = nextMatchTimerDisplayEl; overlayPrefix = "Next match starts in: "; break;
                 case 'BETWEEN_GAMES': statusText = `Preparing Next Match... Betting Open!`; break;
                 default: statusText = "Waiting for server update..."; break;
            }
            gameStatusMessageEl.textContent = statusText;
            if (overlayTimerEl && breakEndTime) { startBreakTimer(overlayTimerEl, overlayPrefix); }
        }
        function startBreakTimer(displayElement, prefix) { clearTimeout(breakTimerInterval); const updateTimer = () => { if (!breakEndTime) { if(displayElement) displayElement.textContent = prefix + "00:00"; return; } const now = Date.now(); const timeLeftS = Math.max(0, Math.floor((breakEndTime - now) / 1000)); const mins = Math.floor(timeLeftS / 60); const secs = timeLeftS % 60; if(displayElement) displayElement.textContent = `${prefix}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; if (timeLeftS > 0) { const msToNextSecond = 1000 - (Date.now() % 1000); breakTimerInterval = setTimeout(updateTimer, msToNextSecond); } else { if(displayElement) displayElement.textContent = prefix + "00:00"; } }; updateTimer(); }

        // --- Drawing Functions ---
        function drawField() { ctx.fillStyle = '#2a8c3e'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, CENTER_CIRCLE_RADIUS * (canvas.width / FIELD_WIDTH), 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 5 * (canvas.width / FIELD_WIDTH) , 0, Math.PI*2); ctx.fill(); const goalDrawWidth = GOAL_WIDTH * (canvas.height / FIELD_HEIGHT); const goalDrawDepth = GOAL_DEPTH * (canvas.width / FIELD_WIDTH); ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; ctx.fillRect(0, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.fillRect(canvas.width - goalDrawDepth, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; const penaltyAreaWidth = 165 * (canvas.width / FIELD_WIDTH); const penaltyAreaHeight = 403 * (canvas.height / FIELD_HEIGHT); ctx.strokeRect(0, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); ctx.strokeRect(canvas.width - penaltyAreaWidth, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); }
        function drawPlayer(player) { const canvasX = player.x * (canvas.width / FIELD_WIDTH); const canvasY = player.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = PLAYER_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = player.color || '#CCCCCC'; ctx.beginPath(); ctx.arc(canvasX, canvasY, canvasRadius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = ball.ownerId === player.id ? '#FFFF00' : '#000000'; ctx.lineWidth = ball.ownerId === player.id ? 2.5 : 1; ctx.stroke(); ctx.fillStyle = player.textColor || '#000000'; ctx.font = `bold ${canvasRadius * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(player.initials || 'P?', canvasX, canvasY); }
        function drawBall() { const canvasX = ball.x * (canvas.width / FIELD_WIDTH); const canvasY = ball.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = BALL_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(canvasX, canvasY, Math.max(2, canvasRadius), 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
        function drawGame() { const currentWidth = canvas.clientWidth; const currentHeight = canvas.clientHeight; if (canvas.width !== currentWidth || canvas.height !== currentHeight) { canvas.width = currentWidth; canvas.height = currentHeight; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawField(); if (players && players.length > 0) { players.forEach(drawPlayer); } if (ball) { drawBall(); } }

        // --- Client Rendering Loop ---
        function mainLoop() { drawGame(); animationFrameId = requestAnimationFrame(mainLoop); }
        function startRendering() { if (!animationFrameId) { animationFrameId = requestAnimationFrame(mainLoop); } }
        function stopRendering() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Utility Functions (Client-side) ---
        function formatTime(ingameSeconds) { const totalSeconds = Math.max(0, Math.floor(ingameSeconds)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function addChatMessage(sender, message) { const messageEl = document.createElement('div'); const safeSender = sender.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); messageEl.innerHTML = `<strong>${safeSender}:</strong> ${safeMessage}`; chatBoxEl.appendChild(messageEl); chatBoxEl.scrollTop = chatBoxEl.scrollHeight; }
        function setBetMessage(message, isError = false) { betMessageEl.textContent = message; betMessageEl.className = `bet-message ${isError ? 'bet-error' : ''}`; }
        function getPlayerInitials(name) { if (!name || typeof name !== 'string') return '??'; const parts = name.trim().split(' '); if (parts.length >= 2) { return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase(); } else if (parts.length === 1 && name.length > 0) { return name.substring(0, Math.min(2, name.length)).toUpperCase(); } return '??'; }
        function disableInteraction(reason = "Disabled") { chatInputEl.disabled = true; sendChatBtn.disabled = true; chatInputEl.placeholder = reason; disableBetting(reason); }
        function disableBetting(message) { betAmountInputEl.disabled = true; betButtonAEl.disabled = true; betButtonBEl.disabled = true; setBetMessage(message, true); }
        function checkBettingStatus() { const isBettingPeriod = (currentGameState === 'INITIAL_BETTING' || currentGameState === 'FULL_TIME' || currentGameState === 'PRE_MATCH' || currentGameState === 'BETWEEN_GAMES'); if (!userNickname) { disableBetting("Enter nickname to bet."); return; } if (currentBet) { const betOnTeamName = currentBet.team === 'A' ? (betTeamANameEl.textContent || 'Team A') : (betTeamBNameEl.textContent || 'Team B'); disableBetting(`Bet placed: $${currentBet.amount} on ${betOnTeamName}.`); return; } if (userBalance <= 0) { disableBetting("Balance is $0.00. Cannot place bets."); return; } if (isBettingPeriod) { betButtonAEl.disabled = false; betButtonBEl.disabled = false; betAmountInputEl.disabled = false; setBetMessage("Betting is open!", false); } else { disableBetting("Betting is closed."); } }

        // --- Initialization ---
        function init() {
            console.log("Client initializing...");
            submitNicknameBtn.addEventListener('click', () => { const nick = nicknameInputEl.value.trim(); if (nick && nick.length > 0 && nick.length <= 15) { sendMessage('setNickname', nick); } else { alert("Please enter a valid nickname (1-15 characters)."); } });
            nicknameInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitNicknameBtn.click(); });
            sendChatBtn.addEventListener('click', () => { const message = chatInputEl.value.trim(); if (message) { sendMessage('chatMessage', message); chatInputEl.value = ''; } });
            chatInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !sendChatBtn.disabled) sendChatBtn.click(); });
            betButtonAEl.addEventListener('click', () => { const amount = parseInt(betAmountInputEl.value, 10); if (!isNaN(amount) && amount > 0) { disableBetting("Placing bet..."); sendMessage('placeBet', { team: 'A', amount: amount }); } else { setBetMessage("Invalid bet amount.", true); } });
            betButtonBEl.addEventListener('click', () => { const amount = parseInt(betAmountInputEl.value, 10); if (!isNaN(amount) && amount > 0) { disableBetting("Placing bet..."); sendMessage('placeBet', { team: 'B', amount: amount }); } else { setBetMessage("Invalid bet amount.", true); } });
            disableInteraction("Connecting..."); userBalanceEl.textContent = '---';
            drawField(); // Initial static draw
            startRendering();
            connectWebSocket(); // Start connection attempts
            console.log("Client init complete.");
        }

        window.onload = init;

    </script>
</body>
</html>