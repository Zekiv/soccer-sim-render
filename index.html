<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Tournament Sim</title>
    <style>
        /* Basic Reset & Font */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; color: #333; height: 100vh; overflow: hidden; padding-top: 5px; /* Space for connection status */ }

        /* Layout Containers */
        .container { display: flex; width: 95%; max-width: 1400px; margin-top: 10px; height: calc(100vh - 150px - 5px); /* Adjust for body padding */ gap: 10px; }
        .game-area { flex-grow: 3; display: flex; flex-direction: column; background-color: #e0e0e0; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; min-width: 400px; /* Prevent excessive shrinking */ }
        .sidebar { flex-grow: 1; background-color: #ffffff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow-y: auto; display: flex; flex-direction: column; min-width: 220px; /* Ensure sidebar readable */ max-width: 300px; }
        .chat-betting-area { width: 95%; max-width: 1400px; height: 120px; display: flex; gap: 10px; margin-top: 10px; }

        /* Game Area Components */
        #gameCanvas { width: 100%; height: calc(100% - 60px); background-color: #2a8c3e; border: 2px solid white; display: block; transition: background-color 0.5s ease; /* For goal flash */ }
        .match-info { display: flex; justify-content: space-around; align-items: center; padding: 10px 0; font-size: 1.2em; font-weight: bold; background-color: #f8f8f8; border-radius: 5px; margin-bottom: 10px; }
        .team-name { flex: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0 10px; min-width: 100px; }
        .score { padding: 0 20px; font-size: 1.3em; }
        .game-time { min-width: 80px; text-align: center; font-variant-numeric: tabular-nums; }

        /* Overlays */
        .halftime-overlay, .fulltime-overlay, .initial-wait-overlay { position: absolute; top: 60px; left: 10px; right: 10px; bottom: 10px; height: calc(100% - 70px); width: calc(100% - 20px); background-color: rgba(0, 0, 0, 0.75); color: white; display: none; /* Hidden by default */ flex-direction: column; justify-content: center; align-items: center; font-size: 2.2em; text-align: center; z-index: 10; border-radius: 5px; box-sizing: border-box; padding: 20px; }
        .initial-wait-overlay .overlay-title, .halftime-overlay .overlay-title, .fulltime-overlay .overlay-title { font-size: 1em; margin-bottom: 10px; } /* Title style */
        .initial-wait-overlay .overlay-details, .halftime-overlay .overlay-details, .fulltime-overlay .overlay-details { font-size: 0.8em; margin-bottom: 20px; font-weight: normal; } /* Score/Details style */
        .initial-wait-overlay span, .halftime-overlay span, .fulltime-overlay span { font-size: 0.7em; margin-top: 15px; font-weight: normal; } /* Timer style */


        /* Sidebar Components */
        .sidebar h3 { margin-top: 0; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 15px; font-size: 1.1em; }
        .stats-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .stats-table th, .stats-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .stats-table th { background-color: #f2f2f2; font-weight: bold; }
        .stats-table .stat-label { text-align: left; font-weight: bold; padding-left: 8px; }
        #teamListEl { font-size: 0.85em; padding-left: 25px; margin-bottom: 20px; list-style: decimal; max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding-top: 5px; padding-bottom: 5px; border-radius: 4px;}
        #teamListEl li { margin-bottom: 3px;}
        #gameStatusMessageEl { text-align: center; margin-top: auto; font-style: italic; padding-top: 15px; border-top: 1px solid #eee; font-size: 0.9em; color: #555; }

        /* Chat/Betting Area */
        .chat-container { flex-grow: 2; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; min-width: 300px; }
        .chat-box { flex-grow: 1; border: 1px solid #ccc; margin-bottom: 5px; padding: 8px; overflow-y: scroll; font-size: 0.9em; background-color: #f9f9f9; height: 60px; line-height: 1.4; }
        .chat-box div { margin-bottom: 4px; word-wrap: break-word; }
        .chat-box strong { color: #0056b3; } /* Make sender name stand out */
        .chat-input { display: flex; }
        .chat-input input { flex-grow: 1; padding: 6px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; }
        .chat-input button { padding: 6px 12px; margin-left: 5px; cursor: pointer; border: none; background-color: #4CAF50; color: white; border-radius: 3px; transition: background-color 0.2s; }
        .chat-input button:hover:not(:disabled) { background-color: #45a049; }

        .betting-container { flex-grow: 1; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: space-between; min-width: 280px; }
        .balance { text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 1.1em; }
        .betting-controls { display: flex; flex-direction: column; gap: 6px; }
        .bet-options { display: flex; justify-content: space-around; font-size: 0.95em; margin-bottom: 5px; }
        .bet-team { font-weight: bold; }
        .bet-odds { color: #007bff; font-weight: bold; }
        .bet-input-area { display: flex; gap: 5px; }
        .bet-input-area input { width: 70px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; text-align: right; }
        .bet-input-area button { padding: 5px 10px; cursor: pointer; border: none; color: white; border-radius: 3px; font-size: 0.9em; flex-grow: 1; transition: background-color 0.2s; }
        .bet-button-a { background-color: #2196F3; }
        .bet-button-a:hover:not(:disabled) { background-color: #1e88e5; }
        .bet-button-b { background-color: #f44336; }
        .bet-button-b:hover:not(:disabled) { background-color: #e53935; }
        button:disabled { background-color: #ccc !important; cursor: not-allowed !important; color: #666 !important; }
        .bet-message { font-size: 0.85em; color: green; text-align: center; min-height: 1.3em; margin-top: 5px; font-weight: bold; }
        .bet-error { color: red; }

        /* Nickname Modal */
        #nicknameModal { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: white; padding: 35px 40px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content label { display: block; margin-bottom: 12px; font-size: 1.15em; color: #333; }
        .modal-content input { padding: 9px 10px; margin-bottom: 18px; width: 220px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em;}
        .modal-content button { padding: 10px 25px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 1em; transition: background-color 0.2s; }
        .modal-content button:hover { background-color: #45a049; }

        /* Connection Status */
        #connectionStatus { position: fixed; top: 0; left: 0; width: 100%; background-color: #ffc107; color: #333; padding: 4px 0; text-align: center; font-size: 0.85em; z-index: 1001; transition: background-color 0.5s ease, color 0.5s ease; }
        #connectionStatus.connected { background-color: #28a745; color: white; }
        #connectionStatus.error { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <div id="connectionStatus">Connecting...</div>

    <div id="nicknameModal">
         <div class="modal-content">
            <label for="nicknameInput">Enter Nickname (1-15 chars):</label>
            <input type="text" id="nicknameInput" maxlength="15">
            <button id="submitNickname">Join Interaction</button>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
             <div class="match-info">
                  <span id="teamANameEl" class="team-name">---</span>
                  <span class="score"><span id="scoreA">0</span> - <span id="scoreB">0</span></span>
                  <span id="teamBNameEl" class="team-name">---</span>
                  <span id="gameTimeEl" class="game-time">00:00</span>
             </div>
            <canvas id="gameCanvas"></canvas>
            <!-- Overlays -->
             <div id="initialWaitOverlay" class="initial-wait-overlay">
                 <div class="overlay-title">Tournament Starting Soon!</div>
                 <div class="overlay-details" id="initialWaitDetails">Betting open for first match...</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
             <div id="halftimeOverlay" class="halftime-overlay">
                 <div class="overlay-title">Halftime</div>
                 <div class="overlay-details" id="halftimeDetails">Score: 0 - 0</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
             <div id="fulltimeOverlay" class="fulltime-overlay">
                 <div class="overlay-title">Full Time!</div>
                 <div class="overlay-details" id="fulltimeDetails">Final Score: 0 - 0</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
        </div>

        <div class="sidebar">
             <h3>Live Statistics</h3>
             <table class="stats-table">
                 <thead><tr><th>Stat</th><th id="statsTeamAHeader">A</th><th id="statsTeamBHeader">B</th></tr></thead>
                 <tbody>
                     <tr><td class="stat-label">Possession</td><td id="possessionA">--%</td><td id="possessionB">--%</td></tr>
                     <tr><td class="stat-label">Goals</td><td id="goalsA">0</td><td id="goalsB">0</td></tr>
                     <tr><td class="stat-label">Shots</td><td id="shotsA">0</td><td id="shotsB">0</td></tr>
                      <tr><td class="stat-label">Passes</td><td id="passesA">0</td><td id="passesB">0</td></tr>
                 </tbody>
             </table>
             <h3>Tournament Teams</h3>
             <ul id="teamListEl">
                 <!-- Populated by JS -->
                  <li>Loading teams...</li>
             </ul>
             <div id="gameStatusMessageEl">Connecting...</div>
        </div>
    </div>

    <div class="chat-betting-area">
        <div class="chat-container">
             <div id="chatBoxEl" class="chat-box">Welcome! Connecting...</div>
             <div class="chat-input">
                 <input type="text" id="chatInputEl" placeholder="Enter nickname to type..." maxlength="100" disabled>
                 <button id="sendChatBtn" disabled>Send</button>
             </div>
         </div>
         <div class="betting-container">
             <div class="balance">Balance: $<span id="userBalanceEl">---</span></div>
              <div id="bettingControls" class="betting-controls">
                  <div class="bet-options"><div><span class="bet-team" id="betTeamANameEl">Team A</span>: <span class="bet-odds" id="oddsAEl">?.??</span></div><div><span class="bet-team" id="betTeamBNameEl">Team B</span>: <span class="bet-odds" id="oddsBEl">?.??</span></div></div>
                  <div class="bet-input-area"><input type="number" id="betAmountInputEl" min="1" step="1" placeholder="Amt" disabled><button id="betButtonAEl" class="bet-button bet-button-a" disabled>Bet A</button><button id="betButtonBEl" class="bet-button bet-button-b" disabled>Bet B</button></div>
                  <div id="betMessageEl" class="bet-message">Enter nickname to enable betting.</div>
              </div>
         </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const teamANameEl = document.getElementById('teamANameEl');
        const teamBNameEl = document.getElementById('teamBNameEl');
        const scoreAEl = document.getElementById('scoreA');
        const scoreBEl = document.getElementById('scoreB');
        const gameTimeEl = document.getElementById('gameTimeEl');
        const statsTeamAHeaderEl = document.getElementById('statsTeamAHeader');
        const statsTeamBHeaderEl = document.getElementById('statsTeamBHeader');
        const possessionAEl = document.getElementById('possessionA');
        const possessionBEl = document.getElementById('possessionB');
        const goalsAEl = document.getElementById('goalsA');
        const goalsBEl = document.getElementById('goalsB');
        const shotsAEl = document.getElementById('shotsA');
        const shotsBEl = document.getElementById('shotsB');
        const passesAEl = document.getElementById('passesA');
        const passesBEl = document.getElementById('passesB');
        const teamListEl = document.getElementById('teamListEl');
        const gameStatusMessageEl = document.getElementById('gameStatusMessageEl');
        const chatBoxEl = document.getElementById('chatBoxEl');
        const chatInputEl = document.getElementById('chatInputEl');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const userBalanceEl = document.getElementById('userBalanceEl');
        const betTeamANameEl = document.getElementById('betTeamANameEl');
        const betTeamBNameEl = document.getElementById('betTeamBNameEl');
        const oddsAEl = document.getElementById('oddsAEl');
        const oddsBEl = document.getElementById('oddsBEl');
        const betAmountInputEl = document.getElementById('betAmountInputEl');
        const betButtonAEl = document.getElementById('betButtonAEl');
        const betButtonBEl = document.getElementById('betButtonBEl');
        const betMessageEl = document.getElementById('betMessageEl');
        const nicknameModalEl = document.getElementById('nicknameModal');
        const nicknameInputEl = document.getElementById('nicknameInput');
        const submitNicknameBtn = document.getElementById('submitNickname');
        // Overlays
        const initialWaitOverlayEl = document.getElementById('initialWaitOverlay');
        const halftimeOverlayEl = document.getElementById('halftimeOverlay');
        const fulltimeOverlayEl = document.getElementById('fulltimeOverlay');
        const initialWaitDetailsEl = document.getElementById('initialWaitDetails');
        const halftimeDetailsEl = document.getElementById('halftimeDetails');
        const fulltimeDetailsEl = document.getElementById('fulltimeDetails');
        const initialTimerDisplayEl = initialWaitOverlayEl.querySelector('span');
        const breakTimerDisplayEl = halftimeOverlayEl.querySelector('span');
        const nextMatchTimerDisplayEl = fulltimeOverlayEl.querySelector('span');
        const connectionStatusEl = document.getElementById('connectionStatus');

        // --- Client State ---
        let players = [];
        let ball = { x: 0, y: 0, vx: 0, vy: 0, ownerId: null };
        let currentGameState = 'INITIALIZING';
        let userNickname = null;
        let userBalance = 0;
        let currentBet = null; // Stores { team: 'A'|'B', amount: number } if a bet is active for the *current* betting cycle
        let breakEndTime = null;
        let breakTimerInterval = null;
        let animationFrameId = null;
        let socket = null;
        let serverTeamA = null; // Stores the *current* match teams from server state
        let serverTeamB = null;
        let serverOddsA = null; // Stores the *current* match odds from server state
        let serverOddsB = null;
        let nextMatchInfo = null; // Stores { teamA, teamB, oddsA, oddsB } for the *upcoming* match during FULL_TIME break
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY_MS = 5000;
        let lastScoreA = 0; // Store score for overlay updates
        let lastScoreB = 0;

        // --- Constants ---
        const FIELD_WIDTH = 1050; const FIELD_HEIGHT = 680; const PLAYER_RADIUS = 10; const BALL_RADIUS = 5; const GOAL_WIDTH = 120; const GOAL_DEPTH = 20; const CENTER_CIRCLE_RADIUS = 91.5;

        // --- WebSocket Connection ---
        function connectWebSocket() {
            // ... (WebSocket connection logic - unchanged) ...
             if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
                console.error("Max reconnection attempts reached. Please refresh the page.");
                connectionStatusEl.textContent = 'Connection Failed. Please Refresh.';
                connectionStatusEl.className = 'error';
                disableInteraction("Connection Failed");
                return;
            }
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log(`Attempting WebSocket connection to: ${wsUrl} (Attempt ${reconnectAttempts + 1})`);
            connectionStatusEl.textContent = `Connecting... (Attempt ${reconnectAttempts + 1})`;
            connectionStatusEl.className = '';
            if (socket && socket.readyState !== WebSocket.CLOSED) { socket.close(); }
            socket = new WebSocket(wsUrl);
            socket.onopen = () => { console.log('WebSocket connection established.'); connectionStatusEl.textContent = 'Connected'; connectionStatusEl.className = 'connected'; gameStatusMessageEl.textContent = "Connected. Waiting for game state..."; reconnectAttempts = 0; if(userNickname){ sendMessage('setNickname', userNickname); /* Re-submit nickname on reconnect */ } }; // Re-submit nickname if already set
            socket.onmessage = (event) => { handleServerMessage(event.data); };
            socket.onerror = (error) => { console.error('WebSocket error:', error); connectionStatusEl.textContent = 'Connection Error'; connectionStatusEl.className = 'error'; };
            socket.onclose = (event) => { console.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'N/A'}`); connectionStatusEl.textContent = 'Disconnected. Retrying...'; connectionStatusEl.className = 'error'; gameStatusMessageEl.textContent = "Disconnected. Attempting to reconnect..."; disableInteraction("Disconnected"); stopRendering(); clearTimeout(breakTimerInterval); hideOverlays(); reconnectAttempts++; setTimeout(connectWebSocket, RECONNECT_DELAY_MS); };
        }
        function sendMessage(type, payload) { if (socket && socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify({ type, payload })); } else { console.error("WebSocket is not open. Cannot send message:", type); addChatMessage("System", "[Error: Cannot send message - not connected]"); } }

        // --- Message Handling ---
        function handleServerMessage(jsonData) {
             let data;
             try { data = JSON.parse(jsonData); } catch (error) { console.error('Failed to parse message JSON:', jsonData, error); addChatMessage("System", "[Received invalid data from server]"); return; }
            const { type, payload } = data;

             // Clear next match info if a state arrives that isn't 'fullTime' or part of the initial load
             if (type !== 'fullTime' && type !== 'currentGameState' && type !== 'betResult') {
                 nextMatchInfo = null;
             }

            switch (type) {
                case 'currentGameState': // Initial state load or major change broadcast
                    console.log("Received full game state:", payload.gameState);
                    // Update core state (current match details)
                    serverTeamA = payload.teamA;
                    serverTeamB = payload.teamB;
                    serverOddsA = payload.oddsA;
                    serverOddsB = payload.oddsB;
                    currentGameState = payload.gameState;
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || [];
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2, vx: 0, vy: 0, ownerId: null };
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    if (payload.allTournamentTeams && Array.isArray(payload.allTournamentTeams)) {
                         populateTeamList(payload.allTournamentTeams);
                    }

                    // Determine which teams/odds to display based on the state received
                    if (currentGameState === 'FULL_TIME' && payload.nextMatch) {
                         nextMatchInfo = payload.nextMatch; // Store the upcoming match details
                         console.log("Storing next match info from fullGameState:", nextMatchInfo);
                         // Show *upcoming* match in betting UI
                         updateTeamUI(nextMatchInfo.teamA, nextMatchInfo.teamB, nextMatchInfo.oddsA, nextMatchInfo.oddsB, 'bettingOnly');
                         // Show *current/last* match in main score bar
                         updateTeamUI(serverTeamA, serverTeamB, null, null, 'scoreBarOnly');
                    } else {
                         // For all other states, betting and score bar show the same current teams/odds
                         updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all');
                         nextMatchInfo = null; // Clear any stale next match info
                    }

                    handleGameStateChange(currentGameState, payload); // Update status text, overlays
                    checkBettingStatus();
                    break;

                // Specific state transitions (mostly update subset of data)
                case 'initialWait': // Happens only once at the start
                    console.log("Handling initialWait");
                    serverTeamA = payload.teamA; serverTeamB = payload.teamB; serverOddsA = payload.oddsA; serverOddsB = payload.oddsB;
                    currentGameState = 'INITIAL_BETTING';
                    updateScoreAndTime(0, 0, 0);
                    players = []; ball = { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); // Show first match teams everywhere
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus();
                    break;

                case 'preMatch': // Sent just before a match starts
                    console.log("Handling preMatch");
                    serverTeamA = payload.teamA; serverTeamB = payload.teamB; serverOddsA = payload.oddsA; serverOddsB = payload.oddsB;
                    currentGameState = 'PRE_MATCH';
                    nextMatchInfo = null; // The match is about to start, clear next match info
                    updateScoreAndTime(0, 0, 0);
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); // Ensure current teams are shown everywhere
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus(); // Betting might still be open briefly
                    break;

                case 'matchStart': // First half begins
                    console.log("Handling matchStart");
                    // Server might re-send teams/odds, update our core state
                    serverTeamA = payload.teamA || serverTeamA; serverTeamB = payload.teamB || serverTeamB; serverOddsA = payload.oddsA || serverOddsA; serverOddsB = payload.oddsB || serverOddsB;
                    currentGameState = 'FIRST_HALF';
                    nextMatchInfo = null; // Clear any previous next match info
                    updateScoreAndTime(0, 0, 0);
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); // Ensure current match displayed
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus(); // Betting should close
                    break;

                case 'gameStateUpdate': // Regular update during active play
                    // Only update dynamic elements: score, time, players, ball, stats
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || [];
                    ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    // Team names/odds in UI should NOT change based on this message
                    break;

                case 'goalScored':
                    console.log("Handling goalScored");
                    // Update score immediately
                    lastScoreA = payload.scoreA; lastScoreB = payload.scoreB;
                    updateScoreAndTime(payload.scoreA, payload.scoreB);
                    addChatMessage("System", `âš½ GOAL! ${payload.scoringTeam === 'A' ? (serverTeamA?.name || 'Team A') : (serverTeamB?.name || 'Team B')} scores! (${payload.scoreA}-${payload.scoreB})`);
                    goalsAEl.textContent = payload.scoreA; // Update stats table goals
                    goalsBEl.textContent = payload.scoreB;
                    // Flash background
                    canvas.style.transition = 'none'; canvas.style.backgroundColor = '#FFF';
                    setTimeout(() => { canvas.style.transition = 'background-color 0.5s ease'; canvas.style.backgroundColor = '#2a8c3e'; }, 100);
                    break;

                case 'halfTime':
                    console.log("Handling halfTime");
                    currentGameState = 'HALF_TIME';
                    updateScoreAndTime(payload.scoreA, payload.scoreB, 45 * 60); // Set time to 45:00
                    lastScoreA = payload.scoreA; lastScoreB = payload.scoreB; // Store for overlay
                    nextMatchInfo = null; // No next match info relevant here
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); // Show current teams
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus(); // Should disable betting
                    break;

                case 'secondHalfStart':
                    console.log("Handling secondHalfStart");
                    currentGameState = 'SECOND_HALF';
                    nextMatchInfo = null; // Clear any lingering next match info
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); // Ensure current teams shown
                    handleGameStateChange(currentGameState, payload);
                    checkBettingStatus(); // Should disable betting
                    break;

                case 'fullTime': // Match finished, break starts
                    console.log("Handling fullTime", payload);
                    currentGameState = 'FULL_TIME';
                    updateScoreAndTime(payload.scoreA, payload.scoreB, 90 * 60); // Set time to 90:00
                    lastScoreA = payload.scoreA; lastScoreB = payload.scoreB; // Store for overlay

                    currentBet = null; // Bets resolved server-side, clear local bet state regardless of result message timing

                    // Store the *next* match details received in the payload
                    if (payload.nextMatch && payload.nextMatch.teamA && payload.nextMatch.teamB) {
                        nextMatchInfo = payload.nextMatch;
                        console.log("Stored next match info:", nextMatchInfo);
                        // Update betting UI immediately to show next match
                        updateTeamUI(nextMatchInfo.teamA, nextMatchInfo.teamB, nextMatchInfo.oddsA, nextMatchInfo.oddsB, 'bettingOnly');
                        // Update score bar to show the final score of the *last* match
                        updateTeamUI(serverTeamA, serverTeamB, null, null, 'scoreBarOnly');
                    } else {
                        nextMatchInfo = null; // Clear if no next match info provided
                        // Show last match details everywhere if no next info
                        updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all');
                        console.warn("FullTime message received without next match details.");
                    }

                    handleGameStateChange(currentGameState, payload); // Show overlay etc.
                    checkBettingStatus(); // Enable betting for the *next* match
                    break;

                // User/Interaction related messages
                case 'welcome':
                    console.log("Handling welcome");
                    userNickname = payload.nickname;
                    userBalance = payload.balance;
                    currentBet = payload.currentBet; // Load existing bet state if any
                    nicknameModalEl.style.display = 'none';
                    chatInputEl.disabled = false; sendChatBtn.disabled = false; chatInputEl.placeholder = "Type message...";
                    userBalanceEl.textContent = userBalance.toFixed(2);
                    addChatMessage("System", `Welcome, ${userNickname}! Balance: $${userBalance.toFixed(2)}.`);
                    checkBettingStatus(); // Re-check betting based on game state & loaded bet
                    break;

                case 'chatBroadcast':
                    addChatMessage(payload.sender, payload.message);
                    break;

                case 'betResult':
                    console.log("Handling betResult", payload);
                    setBetMessage(payload.message, !payload.success);
                    if (payload.newBalance !== undefined) {
                        userBalance = payload.newBalance;
                        userBalanceEl.textContent = userBalance.toFixed(2);
                    }
                    // Clear local bet state if the bet was accepted OR resolved (win/loss/refund)
                    // Don't clear for errors like "betting closed" or "insufficient funds" before placement.
                    if (payload.message.includes("placed") || payload.message.includes("WON!") || payload.message.includes("LOST") || payload.message.includes("refunded")) {
                        // If the message indicates placement *success*, currentBet should have been set locally already.
                        // If the message indicates resolution (win/loss/refund), clear the local bet state.
                        if (!payload.message.includes("placed")) {
                            currentBet = null;
                        }
                    }
                     // Re-evaluate betting buttons immediately after result
                    checkBettingStatus();
                    break;

                 case 'systemMessage':
                     addChatMessage("System", `[Server: ${payload.message}]`);
                     if (payload.isError) { setBetMessage(`Server: ${payload.message}`, true); }
                     break;

                default:
                    console.warn('Unknown message type received:', type);
                    break;
            }
        }

        // --- UI Update Functions ---

        // Simplified: Updates core state variables. Called by message handler.
        function updateCoreMatchState(teamA, teamB, oddsA, oddsB, scoreA, scoreB, timeS) {
             serverTeamA = teamA; serverTeamB = teamB;
             serverOddsA = oddsA; serverOddsB = oddsB;
             lastScoreA = scoreA; lastScoreB = scoreB;
             updateScoreAndTime(scoreA, scoreB, timeS);
        }

         // REVISED: updateTeamUI - targets specific UI areas
         function updateTeamUI(teamA, teamB, oddsAVal, oddsBVal, target = 'all') { // target: 'all', 'bettingOnly', 'scoreBarOnly'
             const nameA = teamA?.name || '---';
             const nameB = teamB?.name || '---';
             const initialsA = getPlayerInitials(nameA || 'A');
             const initialsB = getPlayerInitials(nameB || 'B');

             // Update main match info bar (score bar)
             if (target === 'all' || target === 'scoreBarOnly') {
                 teamANameEl.textContent = nameA;
                 teamBNameEl.textContent = nameB;
             }

             // Update betting area
             if (target === 'all' || target === 'bettingOnly') {
                 betTeamANameEl.textContent = nameA;
                 betTeamBNameEl.textContent = nameB;
                 oddsAEl.textContent = oddsAVal !== undefined && oddsAVal !== null ? parseFloat(oddsAVal).toFixed(2) : '?.??';
                 oddsBEl.textContent = oddsBVal !== undefined && oddsBVal !== null ? parseFloat(oddsBVal).toFixed(2) : '?.??';
             }

             // Update stats headers (use initials from score bar context if split)
             if (target === 'all' || target === 'scoreBarOnly') {
                 statsTeamAHeaderEl.textContent = initialsA;
                 statsTeamBHeaderEl.textContent = initialsB;
             } else if (target === 'bettingOnly' && serverTeamA && serverTeamB) {
                 // If only updating betting, stats header should still show *current* match teams
                 statsTeamAHeaderEl.textContent = getPlayerInitials(serverTeamA.name || 'A');
                 statsTeamBHeaderEl.textContent = getPlayerInitials(serverTeamB.name || 'B');
             }
         }

         function updateScoreAndTime(sA, sB, timeS) {
             if (sA !== undefined && sA !== null) scoreAEl.textContent = sA;
             if (sB !== undefined && sB !== null) scoreBEl.textContent = sB;
             if (sA !== undefined && sA !== null) goalsAEl.textContent = sA; // Update stats table too
             if (sB !== undefined && sB !== null) goalsBEl.textContent = sB;
             if (timeS !== undefined && timeS !== null) gameTimeEl.textContent = formatTime(timeS);
             // Store last known scores for overlays
             if (sA !== undefined && sA !== null) lastScoreA = sA;
             if (sB !== undefined && sB !== null) lastScoreB = sB;
         }

         function updateStatsUI(statsData) {
             if (!statsData) return;
             const safeStat = (teamStat, key, defaultVal) => teamStat && teamStat[key] !== undefined && teamStat[key] !== null ? teamStat[key] : defaultVal;

             if(statsData.teamA) {
                 shotsAEl.textContent = safeStat(statsData.teamA, 'shots', shotsAEl.textContent);
                 passesAEl.textContent = safeStat(statsData.teamA, 'passes', passesAEl.textContent);
                 // Goals updated via updateScoreAndTime now
             }
             if(statsData.teamB) {
                 shotsBEl.textContent = safeStat(statsData.teamB, 'shots', shotsBEl.textContent);
                 passesBEl.textContent = safeStat(statsData.teamB, 'passes', passesBEl.textContent);
                 // Goals updated via updateScoreAndTime now
             }
             const passesA = parseInt(passesAEl.textContent) || 0;
             const passesB = parseInt(passesBEl.textContent) || 0;
             const totalPasses = passesA + passesB;

             if (totalPasses > 0) {
                 possessionAEl.textContent = Math.round((passesA / totalPasses) * 100) + '%';
                 possessionBEl.textContent = Math.round((passesB / totalPasses) * 100) + '%';
             } else {
                 possessionAEl.textContent = '50%';
                 possessionBEl.textContent = '50%';
             }
         }

         // REVISED: populateTeamList
         function populateTeamList(teamNames) {
             if (!teamListEl) return;
             teamListEl.innerHTML = ''; // Clear previous entries
             if (!teamNames || teamNames.length === 0) {
                 const li = document.createElement('li');
                 li.textContent = 'Team list unavailable.';
                 teamListEl.appendChild(li);
                 return;
             }
             teamNames.forEach(name => {
                 const li = document.createElement('li');
                 li.textContent = name;
                 teamListEl.appendChild(li);
             });
         }


        // --- Game State Change & Timers ---
        function hideOverlays() { initialWaitOverlayEl.style.display = 'none'; halftimeOverlayEl.style.display = 'none'; fulltimeOverlayEl.style.display = 'none'; }

        // REVISED: handleGameStateChange - Updates overlays and status messages
        function handleGameStateChange(newState, payload) {
            hideOverlays();
            clearTimeout(breakTimerInterval);
            breakEndTime = payload?.breakEndTime; // Comes from initialWait, halfTime, fullTime messages
            let statusText = "";
            let overlayTimerEl = null;
            let overlayPrefix = "";

            // Determine teams/scores for status messages and overlays
            // Uses serverTeamA/B (current/last match) and lastScoreA/B
            const nameA = serverTeamA?.name || 'Team A';
            const nameB = serverTeamB?.name || 'Team B';
            const scoreStr = `${lastScoreA} - ${lastScoreB}`;

            switch (newState) {
                case 'INITIALIZING':
                    statusText = "Initializing...";
                    break;
                case 'INITIAL_BETTING':
                    initialWaitOverlayEl.style.display = 'flex';
                    initialWaitDetailsEl.textContent = `Betting open: ${nameA} vs ${nameB}`;
                    statusText = `Betting open for first match: ${nameA} vs ${nameB}!`;
                    overlayTimerEl = initialTimerDisplayEl;
                    overlayPrefix = "First match starts in: ";
                    break;
                case 'PRE_MATCH':
                    // Scoreboard/Betting UI updated by 'preMatch' message handler
                    statusText = `Starting Soon: ${nameA} vs ${nameB}. Betting closing...`;
                    break;
                case 'FIRST_HALF':
                     // Scoreboard UI updated by 'matchStart' or 'gameStateUpdate'
                     statusText = `Match Running: ${nameA} ${scoreAEl.textContent}-${scoreBEl.textContent} ${nameB} (1st Half)`;
                     break;
                case 'HALF_TIME':
                    halftimeOverlayEl.style.display = 'flex';
                    halftimeDetailsEl.textContent = `Score: ${nameA} ${scoreStr} ${nameB}`; // Use last known score
                    statusText = `Half Time: ${nameA} ${scoreStr} ${nameB}. Betting closed.`;
                    overlayTimerEl = breakTimerDisplayEl;
                    overlayPrefix = "2nd Half starts in: ";
                    break;
                case 'SECOND_HALF':
                     // Scoreboard UI updated by 'secondHalfStart' or 'gameStateUpdate'
                     statusText = `Match Running: ${nameA} ${scoreAEl.textContent}-${scoreBEl.textContent} ${nameB} (2nd Half)`;
                     break;
                case 'FULL_TIME':
                    fulltimeOverlayEl.style.display = 'flex';
                    fulltimeDetailsEl.textContent = `Final Score: ${nameA} ${scoreStr} ${nameB}`; // Use final score
                    overlayTimerEl = nextMatchTimerDisplayEl;
                    overlayPrefix = "Next match starts in: ";
                    // Determine next match teams for status text
                    const nextNameA = nextMatchInfo?.teamA?.name || 'Next Team A';
                    const nextNameB = nextMatchInfo?.teamB?.name || 'Next Team B';
                    statusText = `Full Time: ${nameA} ${scoreStr} ${nameB}. Betting open for ${nextNameA} vs ${nextNameB}!`;
                    break;
                // case 'BETWEEN_GAMES': // Likely unused now, PRE_MATCH covers the gap
                //     statusText = `Preparing Next Match... Betting Open!`;
                //     break;
                default:
                    statusText = "Waiting for server update...";
                    break;
            }
            gameStatusMessageEl.textContent = statusText;
            if (overlayTimerEl && breakEndTime) {
                startBreakTimer(overlayTimerEl, overlayPrefix);
            }
        }

        function startBreakTimer(displayElement, prefix) { clearTimeout(breakTimerInterval); const updateTimer = () => { if (!breakEndTime || !displayElement) { if(displayElement) displayElement.textContent = prefix + "00:00"; return; } const now = Date.now(); const timeLeftS = Math.max(0, Math.floor((breakEndTime - now) / 1000)); const mins = Math.floor(timeLeftS / 60); const secs = timeLeftS % 60; displayElement.textContent = `${prefix}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; if (timeLeftS > 0) { const msToNextSecond = 1000 - (now % 1000); breakTimerInterval = setTimeout(updateTimer, msToNextSecond); } else { displayElement.textContent = prefix + "00:00"; /* Optionally trigger state check? */ } }; updateTimer(); }


        // --- Drawing Functions ---
        function drawField() { /* ... (unchanged) ... */ ctx.fillStyle = '#2a8c3e'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, CENTER_CIRCLE_RADIUS * (canvas.width / FIELD_WIDTH), 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 5 * (canvas.width / FIELD_WIDTH) , 0, Math.PI*2); ctx.fill(); const goalDrawWidth = GOAL_WIDTH * (canvas.height / FIELD_HEIGHT); const goalDrawDepth = GOAL_DEPTH * (canvas.width / FIELD_WIDTH); ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; ctx.fillRect(0, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.fillRect(canvas.width - goalDrawDepth, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; const penaltyAreaWidth = 165 * (canvas.width / FIELD_WIDTH); const penaltyAreaHeight = 403 * (canvas.height / FIELD_HEIGHT); ctx.strokeRect(0, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); ctx.strokeRect(canvas.width - penaltyAreaWidth, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); }
        function drawPlayer(player) { /* ... (unchanged drawing logic, using player.color etc) ... */ const canvasX = player.x * (canvas.width / FIELD_WIDTH); const canvasY = player.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = PLAYER_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = player.color || '#CCCCCC'; ctx.beginPath(); ctx.arc(canvasX, canvasY, canvasRadius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = ball.ownerId === player.id ? '#FFFF00' : '#000000'; ctx.lineWidth = ball.ownerId === player.id ? 2.5 : 1; ctx.stroke(); ctx.fillStyle = player.textColor || '#000000'; ctx.font = `bold ${canvasRadius * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(player.initials || 'P?', canvasX, canvasY); }
        function drawBall() { /* ... (unchanged) ... */ const canvasX = ball.x * (canvas.width / FIELD_WIDTH); const canvasY = ball.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = BALL_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(canvasX, canvasY, Math.max(2, canvasRadius), 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
        function drawGame() { /* ... (unchanged) ... */ const currentWidth = canvas.clientWidth; const currentHeight = canvas.clientHeight; if (canvas.width !== currentWidth || canvas.height !== currentHeight) { canvas.width = currentWidth; canvas.height = currentHeight; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawField(); if (players && players.length > 0) { players.forEach(drawPlayer); } if (ball) { drawBall(); } }

        // --- Client Rendering Loop ---
        function mainLoop() { drawGame(); animationFrameId = requestAnimationFrame(mainLoop); }
        function startRendering() { if (!animationFrameId) { animationFrameId = requestAnimationFrame(mainLoop); } }
        function stopRendering() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Utility Functions (Client-side) ---
        function formatTime(ingameSeconds) { const totalSeconds = Math.max(0, Math.floor(ingameSeconds)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function addChatMessage(sender, message) { const messageEl = document.createElement('div'); const safeSender = sender.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); messageEl.innerHTML = `<strong>${safeSender}:</strong> ${safeMessage}`; chatBoxEl.appendChild(messageEl); chatBoxEl.scrollTop = chatBoxEl.scrollHeight; }
        function setBetMessage(message, isError = false) { betMessageEl.textContent = message; betMessageEl.className = `bet-message ${isError ? 'bet-error' : ''}`; setTimeout(() => { if (betMessageEl.textContent === message) { checkBettingStatus(); /* Reset message after a delay if still showing this one */ } }, 4000); }
        function getPlayerInitials(name) { if (!name || typeof name !== 'string') return '??'; const parts = name.trim().split(' '); if (parts.length >= 2) { return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase(); } else if (parts.length === 1 && name.length > 0) { return name.substring(0, Math.min(2, name.length)).toUpperCase(); } return '??'; }
        function disableInteraction(reason = "Disabled") { chatInputEl.disabled = true; sendChatBtn.disabled = true; chatInputEl.placeholder = reason; disableBetting(reason); }
        function disableBetting(message, isError = true) { // Default to error=true for disabling
              betAmountInputEl.disabled = true; betButtonAEl.disabled = true; betButtonBEl.disabled = true;
              setBetMessage(message, isError);
          }

        // REVISED: checkBettingStatus - handles currentBet state correctly
        function checkBettingStatus() {
            const isBettingPeriod = (
                currentGameState === 'INITIAL_BETTING' ||
                currentGameState === 'FULL_TIME' ||
                currentGameState === 'PRE_MATCH' // Allow betting briefly before match starts
            );

            if (!userNickname) {
                disableBetting("Enter nickname to bet.", true);
                return;
            }

            // Determine the teams currently displayed in the betting UI for messaging
            const bettingTeamAName = betTeamANameEl.textContent || 'Team A';
            const bettingTeamBName = betTeamBNameEl.textContent || 'Team B';

            if (currentBet) {
                 // A bet has been placed for this betting cycle. Show it and disable further betting.
                 const betOnTeamName = currentBet.team === 'A' ? bettingTeamAName : bettingTeamBName;
                 disableBetting(`Bet placed on ${betOnTeamName} ($${currentBet.amount.toFixed(2)}). Waiting for result.`, false); // false = not an error state
                 return;
            }

            // No current bet placed by the user yet
            if (userBalance <= 0) {
                disableBetting("Balance is $0.00. Cannot place bets.", true);
                return;
            }

            if (isBettingPeriod) {
                // Betting is allowed, no bet placed yet, user has balance
                betButtonAEl.disabled = false;
                betButtonBEl.disabled = false;
                betAmountInputEl.disabled = false;
                // Make the message specific to the teams shown in the betting UI
                setBetMessage(`Betting open for ${bettingTeamAName} vs ${bettingTeamBName}!`, false); // false = not an error
            } else {
                // Betting is closed (e.g., match in progress)
                disableBetting("Betting is closed.", true);
            }
        }


        // --- Event Listeners ---
        function placeBetHandler(team) {
             const amount = parseInt(betAmountInputEl.value, 10);
             if (!isNaN(amount) && amount > 0 && amount <= userBalance) {
                 // Optimistically disable controls and set local state
                 disableBetting("Placing bet...", false);
                 currentBet = { team: team, amount: amount }; // Set local bet state
                 sendMessage('placeBet', { team: team, amount: amount });
                 // Server 'betResult' will confirm or deny
             } else if (amount > userBalance) {
                 setBetMessage("Insufficient balance.", true);
                 currentBet = null; // Ensure local state is clear if bet fails pre-send
                 checkBettingStatus(); // Re-enable if appropriate
             } else {
                 setBetMessage("Invalid bet amount.", true);
                 currentBet = null; // Ensure local state is clear
                 checkBettingStatus(); // Re-enable if appropriate
             }
         }

        // --- Initialization ---
        function init() {
            console.log("Client initializing...");
            submitNicknameBtn.addEventListener('click', () => { const nick = nicknameInputEl.value.trim(); if (nick && nick.length > 0 && nick.length <= 15) { sendMessage('setNickname', nick); } else { alert("Please enter a valid nickname (1-15 characters)."); } });
            nicknameInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitNicknameBtn.click(); });
            sendChatBtn.addEventListener('click', () => { const message = chatInputEl.value.trim(); if (message) { sendMessage('chatMessage', message); chatInputEl.value = ''; } });
            chatInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !sendChatBtn.disabled) sendChatBtn.click(); });

            betButtonAEl.addEventListener('click', () => placeBetHandler('A'));
            betButtonBEl.addEventListener('click', () => placeBetHandler('B'));

            disableInteraction("Connecting..."); userBalanceEl.textContent = '---';
            drawField(); // Initial static draw
            startRendering();
            connectWebSocket(); // Start connection attempts
            console.log("Client init complete.");
        }

        window.onload = init;

    </script>
</body>
</html>
