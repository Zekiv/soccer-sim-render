<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Tournament Sim</title>
    <style>
        /* Basic Reset & Font */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; color: #333; height: 100vh; overflow: hidden; padding-top: 5px; /* Space for connection status */ }

        /* Layout Containers */
        .container { display: flex; width: 95%; max-width: 1400px; margin-top: 10px; height: calc(100vh - 150px - 5px); /* Adjust for body padding */ gap: 10px; }
        .game-area { flex-grow: 3; display: flex; flex-direction: column; background-color: #e0e0e0; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); position: relative; min-width: 400px; /* Prevent excessive shrinking */ }
        .sidebar { flex-grow: 1; background-color: #ffffff; padding: 15px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); overflow-y: auto; display: flex; flex-direction: column; min-width: 220px; /* Ensure sidebar readable */ max-width: 300px; }
        .chat-betting-area { width: 95%; max-width: 1400px; height: 120px; display: flex; gap: 10px; margin-top: 10px; }

        /* Game Area Components */
        #gameCanvas { width: 100%; height: calc(100% - 60px); background-color: #2a8c3e; border: 2px solid white; display: block; transition: background-color 0.5s ease; /* For goal flash */ }
        .match-info { display: flex; justify-content: space-around; align-items: center; padding: 10px 0; font-size: 1.2em; font-weight: bold; background-color: #f8f8f8; border-radius: 5px; margin-bottom: 10px; }
        .team-name { flex: 1; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; padding: 0 10px; min-width: 100px; }
        .score { padding: 0 20px; font-size: 1.3em; }
        .game-time { min-width: 80px; text-align: center; font-variant-numeric: tabular-nums; }

        /* Overlays */
        .halftime-overlay, .fulltime-overlay, .initial-wait-overlay { position: absolute; top: 60px; left: 10px; right: 10px; bottom: 10px; height: calc(100% - 70px); width: calc(100% - 20px); background-color: rgba(0, 0, 0, 0.75); color: white; display: none; /* Hidden by default */ flex-direction: column; justify-content: center; align-items: center; font-size: 2.2em; text-align: center; z-index: 10; border-radius: 5px; box-sizing: border-box; padding: 20px; }
        .initial-wait-overlay .overlay-title, .halftime-overlay .overlay-title, .fulltime-overlay .overlay-title { font-size: 1em; margin-bottom: 10px; } /* Title style */
        .initial-wait-overlay .overlay-details, .halftime-overlay .overlay-details, .fulltime-overlay .overlay-details { font-size: 0.8em; margin-bottom: 20px; font-weight: normal; } /* Score/Details style */
        .initial-wait-overlay span, .halftime-overlay span, .fulltime-overlay span { font-size: 0.7em; margin-top: 15px; font-weight: normal; } /* Timer style */


        /* Sidebar Components */
        .sidebar h3 { margin-top: 0; text-align: center; border-bottom: 1px solid #ccc; padding-bottom: 10px; margin-bottom: 15px; font-size: 1.1em; }
        .stats-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; font-size: 0.9em; }
        .stats-table th, .stats-table td { border: 1px solid #ddd; padding: 6px; text-align: center; }
        .stats-table th { background-color: #f2f2f2; font-weight: bold; }
        .stats-table .stat-label { text-align: left; font-weight: bold; padding-left: 8px; }
        #teamListEl { font-size: 0.85em; padding-left: 25px; margin-bottom: 20px; list-style: decimal; max-height: 200px; overflow-y: auto; border: 1px solid #eee; padding-top: 5px; padding-bottom: 5px; border-radius: 4px;}
        #teamListEl li { margin-bottom: 3px;}

         /* Leaderboard Styles */
         #leaderboardHeader { margin-top: 20px; /* Space above leaderboard */ }
         .leaderboard-list {
              list-style: decimal;
              padding-left: 25px; /* Indent numbers */
              margin-bottom: 15px;
              font-size: 0.9em;
              max-height: 180px; /* Limit height */
              overflow-y: auto;   /* Add scroll if needed */
              border: 1px solid #eee;
              padding-top: 5px;
              padding-bottom: 5px;
              border-radius: 4px;
         }
         .leaderboard-list li {
              margin-bottom: 5px;
              padding-right: 5px; /* Prevent text touching edge */
              display: flex;       /* Use flex for alignment */
              justify-content: space-between; /* Push balance to the right */
         }
         .leaderboard-list .leaderboard-balance {
              font-weight: bold;
              color: #007bff; /* Make balance stand out */
              margin-left: 10px; /* Space between name and balance */
         }
         .leaderboard-list .no-entries {
             font-style: italic;
             color: #888;
             list-style: none; /* Remove number for this message */
         }

        #gameStatusMessageEl { text-align: center; margin-top: auto; font-style: italic; padding-top: 15px; border-top: 1px solid #eee; font-size: 0.9em; color: #555; }

        /* Chat/Betting Area */
        .chat-container { flex-grow: 2; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; min-width: 300px; }
        .chat-box { flex-grow: 1; border: 1px solid #ccc; margin-bottom: 5px; padding: 8px; overflow-y: scroll; font-size: 0.9em; background-color: #f9f9f9; height: 60px; line-height: 1.4; }
        .chat-box div { margin-bottom: 4px; word-wrap: break-word; }
        .chat-box strong { color: #0056b3; } /* Make sender name stand out */
        .chat-input { display: flex; }
        .chat-input input { flex-grow: 1; padding: 6px 8px; border: 1px solid #ccc; border-radius: 3px; font-size: 0.9em; }
        .chat-input button { padding: 6px 12px; margin-left: 5px; cursor: pointer; border: none; background-color: #4CAF50; color: white; border-radius: 3px; transition: background-color 0.2s; }
        .chat-input button:hover:not(:disabled) { background-color: #45a049; }

        .betting-container { flex-grow: 1; background-color: #fff; border-radius: 8px; padding: 10px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); display: flex; flex-direction: column; justify-content: space-between; min-width: 280px; }
        .balance { text-align: center; font-weight: bold; margin-bottom: 5px; font-size: 1.1em; }
        .betting-controls { display: flex; flex-direction: column; gap: 6px; }
        .bet-options { display: flex; justify-content: space-around; font-size: 0.95em; margin-bottom: 5px; }
        .bet-team { font-weight: bold; }
        .bet-odds { color: #007bff; font-weight: bold; }
        .bet-input-area { display: flex; gap: 5px; }
        .bet-input-area input { width: 70px; padding: 5px; border: 1px solid #ccc; border-radius: 3px; text-align: right; }
        .bet-input-area button { padding: 5px 10px; cursor: pointer; border: none; color: white; border-radius: 3px; font-size: 0.9em; flex-grow: 1; transition: background-color 0.2s; }
        .bet-button-a { background-color: #2196F3; }
        .bet-button-a:hover:not(:disabled) { background-color: #1e88e5; }
        .bet-button-b { background-color: #f44336; }
        .bet-button-b:hover:not(:disabled) { background-color: #e53935; }
        button:disabled { background-color: #ccc !important; cursor: not-allowed !important; color: #666 !important; }
        .bet-message { font-size: 0.85em; color: green; text-align: center; min-height: 1.3em; margin-top: 5px; font-weight: bold; }
        .bet-error { color: red; }

        /* Nickname Modal */
        #nicknameModal { position: fixed; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); display: flex; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background-color: white; padding: 35px 40px; border-radius: 8px; text-align: center; box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .modal-content label { display: block; margin-bottom: 12px; font-size: 1.15em; color: #333; }
        .modal-content input { padding: 9px 10px; margin-bottom: 18px; width: 220px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em;}
        .modal-content button { padding: 10px 25px; cursor: pointer; background-color: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 1em; transition: background-color 0.2s; }
        .modal-content button:hover { background-color: #45a049; }

        /* Connection Status */
        #connectionStatus { position: fixed; top: 0; left: 0; width: 100%; background-color: #ffc107; color: #333; padding: 4px 0; text-align: center; font-size: 0.85em; z-index: 1001; transition: background-color 0.5s ease, color 0.5s ease; }
        #connectionStatus.connected { background-color: #28a745; color: white; }
        #connectionStatus.error { background-color: #dc3545; color: white; }
    </style>
</head>
<body>
    <div id="connectionStatus">Connecting...</div>

    <div id="nicknameModal">
         <div class="modal-content">
            <label for="nicknameInput">Enter Nickname (1-15 chars):</label>
            <input type="text" id="nicknameInput" maxlength="15">
            <button id="submitNickname">Join Interaction</button>
        </div>
    </div>

    <div class="container">
        <div class="game-area">
             <div class="match-info">
                  <span id="teamANameEl" class="team-name">---</span>
                  <span class="score"><span id="scoreA">0</span> - <span id="scoreB">0</span></span>
                  <span id="teamBNameEl" class="team-name">---</span>
                  <span id="gameTimeEl" class="game-time">00:00</span>
             </div>
            <canvas id="gameCanvas"></canvas>
            <!-- Overlays -->
             <div id="initialWaitOverlay" class="initial-wait-overlay">
                 <div class="overlay-title">Tournament Starting Soon!</div>
                 <div class="overlay-details" id="initialWaitDetails">Betting open for first match...</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
             <div id="halftimeOverlay" class="halftime-overlay">
                 <div class="overlay-title">Halftime</div>
                 <div class="overlay-details" id="halftimeDetails">Score: 0 - 0</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
             <div id="fulltimeOverlay" class="fulltime-overlay">
                 <div class="overlay-title">Full Time!</div>
                 <div class="overlay-details" id="fulltimeDetails">Final Score: 0 - 0</div>
                 <span></span> <!-- Timer placeholder -->
             </div>
        </div>

        <div class="sidebar">
             <h3>Live Statistics</h3>
             <table class="stats-table">
                 <thead><tr><th>Stat</th><th id="statsTeamAHeader">A</th><th id="statsTeamBHeader">B</th></tr></thead>
                 <tbody>
                     <tr><td class="stat-label">Possession</td><td id="possessionA">--%</td><td id="possessionB">--%</td></tr>
                     <tr><td class="stat-label">Goals</td><td id="goalsA">0</td><td id="goalsB">0</td></tr>
                     <tr><td class="stat-label">Shots</td><td id="shotsA">0</td><td id="shotsB">0</td></tr>
                      <tr><td class="stat-label">Passes</td><td id="passesA">0</td><td id="passesB">0</td></tr>
                 </tbody>
             </table>
             <h3>Tournament Teams</h3>
             <ul id="teamListEl">
                 <li>Loading teams...</li>
             </ul>

             <!-- LEADERBOARD SECTION -->
             <h3 id="leaderboardHeader">Top Bettors</h3>
             <ol id="leaderboardEl" class="leaderboard-list">
                 <li>Loading...</li>
             </ol>
             <!-- END LEADERBOARD SECTION -->

             <div id="gameStatusMessageEl">Connecting...</div>
        </div>
    </div>

    <div class="chat-betting-area">
        <div class="chat-container">
             <div id="chatBoxEl" class="chat-box">Welcome! Connecting...</div>
             <div class="chat-input">
                 <input type="text" id="chatInputEl" placeholder="Enter nickname to type..." maxlength="100" disabled>
                 <button id="sendChatBtn" disabled>Send</button>
             </div>
         </div>
         <div class="betting-container">
             <div class="balance">Balance: $<span id="userBalanceEl">---</span></div>
              <div id="bettingControls" class="betting-controls">
                  <div class="bet-options"><div><span class="bet-team" id="betTeamANameEl">Team A</span>: <span class="bet-odds" id="oddsAEl">?.??</span></div><div><span class="bet-team" id="betTeamBNameEl">Team B</span>: <span class="bet-odds" id="oddsBEl">?.??</span></div></div>
                  <div class="bet-input-area"><input type="number" id="betAmountInputEl" min="1" step="1" placeholder="Amt" disabled><button id="betButtonAEl" class="bet-button bet-button-a" disabled>Bet A</button><button id="betButtonBEl" class="bet-button bet-button-b" disabled>Bet B</button></div>
                  <div id="betMessageEl" class="bet-message">Enter nickname to enable betting.</div>
              </div>
         </div>
    </div>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const teamANameEl = document.getElementById('teamANameEl');
        const teamBNameEl = document.getElementById('teamBNameEl');
        const scoreAEl = document.getElementById('scoreA');
        const scoreBEl = document.getElementById('scoreB');
        const gameTimeEl = document.getElementById('gameTimeEl');
        const statsTeamAHeaderEl = document.getElementById('statsTeamAHeader');
        const statsTeamBHeaderEl = document.getElementById('statsTeamBHeader');
        const possessionAEl = document.getElementById('possessionA');
        const possessionBEl = document.getElementById('possessionB');
        const goalsAEl = document.getElementById('goalsA');
        const goalsBEl = document.getElementById('goalsB');
        const shotsAEl = document.getElementById('shotsA');
        const shotsBEl = document.getElementById('shotsB');
        const passesAEl = document.getElementById('passesA');
        const passesBEl = document.getElementById('passesB');
        const teamListEl = document.getElementById('teamListEl');
        const gameStatusMessageEl = document.getElementById('gameStatusMessageEl');
        const chatBoxEl = document.getElementById('chatBoxEl');
        const chatInputEl = document.getElementById('chatInputEl');
        const sendChatBtn = document.getElementById('sendChatBtn');
        const userBalanceEl = document.getElementById('userBalanceEl');
        const betTeamANameEl = document.getElementById('betTeamANameEl');
        const betTeamBNameEl = document.getElementById('betTeamBNameEl');
        const oddsAEl = document.getElementById('oddsAEl');
        const oddsBEl = document.getElementById('oddsBEl');
        const betAmountInputEl = document.getElementById('betAmountInputEl');
        const betButtonAEl = document.getElementById('betButtonAEl');
        const betButtonBEl = document.getElementById('betButtonBEl');
        const betMessageEl = document.getElementById('betMessageEl');
        const nicknameModalEl = document.getElementById('nicknameModal');
        const nicknameInputEl = document.getElementById('nicknameInput');
        const submitNicknameBtn = document.getElementById('submitNickname');
        const initialWaitOverlayEl = document.getElementById('initialWaitOverlay');
        const halftimeOverlayEl = document.getElementById('halftimeOverlay');
        const fulltimeOverlayEl = document.getElementById('fulltimeOverlay');
        const initialWaitDetailsEl = document.getElementById('initialWaitDetails');
        const halftimeDetailsEl = document.getElementById('halftimeDetails');
        const fulltimeDetailsEl = document.getElementById('fulltimeDetails');
        const initialTimerDisplayEl = initialWaitOverlayEl.querySelector('span');
        const breakTimerDisplayEl = halftimeOverlayEl.querySelector('span');
        const nextMatchTimerDisplayEl = fulltimeOverlayEl.querySelector('span');
        const connectionStatusEl = document.getElementById('connectionStatus');
        const leaderboardEl = document.getElementById('leaderboardEl'); // Leaderboard List Element

        // --- Client State ---
        let players = [];
        let ball = { x: 0, y: 0, vx: 0, vy: 0, ownerId: null };
        let currentGameState = 'INITIALIZING';
        let userNickname = null;
        let userBalance = 0;
        let currentBet = null;
        let breakEndTime = null;
        let breakTimerInterval = null;
        let animationFrameId = null;
        let socket = null;
        let serverTeamA = null;
        let serverTeamB = null;
        let serverOddsA = null;
        let serverOddsB = null;
        let nextMatchInfo = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;
        const RECONNECT_DELAY_MS = 5000;
        let lastScoreA = 0;
        let lastScoreB = 0;

        // --- Constants ---
        const FIELD_WIDTH = 1050; const FIELD_HEIGHT = 680; const PLAYER_RADIUS = 10; const BALL_RADIUS = 5; const GOAL_WIDTH = 120; const GOAL_DEPTH = 20; const CENTER_CIRCLE_RADIUS = 91.5;

        // --- WebSocket Connection ---
        function connectWebSocket() {
            if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) { console.error("Max reconnection attempts reached. Please refresh."); connectionStatusEl.textContent = 'Connection Failed. Please Refresh.'; connectionStatusEl.className = 'error'; disableInteraction("Connection Failed"); return; }
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${wsProtocol}//${window.location.host}`;
            console.log(`Attempting WebSocket connection to: ${wsUrl} (Attempt ${reconnectAttempts + 1})`);
            connectionStatusEl.textContent = `Connecting... (Attempt ${reconnectAttempts + 1})`; connectionStatusEl.className = '';
            if (socket && socket.readyState !== WebSocket.CLOSED) { socket.close(); }
            socket = new WebSocket(wsUrl);
            socket.onopen = () => { console.log('WebSocket connection established.'); connectionStatusEl.textContent = 'Connected'; connectionStatusEl.className = 'connected'; gameStatusMessageEl.textContent = "Connected. Waiting for game state..."; reconnectAttempts = 0; if(userNickname){ sendMessage('setNickname', userNickname); } };
            socket.onmessage = (event) => { handleServerMessage(event.data); };
            socket.onerror = (error) => { console.error('WebSocket error:', error); connectionStatusEl.textContent = 'Connection Error'; connectionStatusEl.className = 'error'; };
            socket.onclose = (event) => { console.log(`WebSocket connection closed: Code ${event.code}, Reason: ${event.reason || 'N/A'}`); connectionStatusEl.textContent = 'Disconnected. Retrying...'; connectionStatusEl.className = 'error'; gameStatusMessageEl.textContent = "Disconnected. Attempting to reconnect..."; disableInteraction("Disconnected"); stopRendering(); clearTimeout(breakTimerInterval); hideOverlays(); reconnectAttempts++; setTimeout(connectWebSocket, RECONNECT_DELAY_MS); };
        }
        function sendMessage(type, payload) { if (socket && socket.readyState === WebSocket.OPEN) { socket.send(JSON.stringify({ type, payload })); } else { console.error("WebSocket is not open. Cannot send message:", type); addChatMessage("System", "[Error: Cannot send message - not connected]"); } }

        // --- Message Handling ---
        function handleServerMessage(jsonData) {
             let data;
             try { data = JSON.parse(jsonData); } catch (error) { console.error('Failed to parse message JSON:', jsonData, error); addChatMessage("System", "[Received invalid data from server]"); return; }
            const { type, payload } = data;

             if (type !== 'fullTime' && type !== 'currentGameState' && type !== 'betResult') { nextMatchInfo = null; }

            switch (type) {
                case 'currentGameState':
                    console.log("Received full game state:", payload.gameState);
                    serverTeamA = payload.teamA; serverTeamB = payload.teamB; serverOddsA = payload.oddsA; serverOddsB = payload.oddsB;
                    currentGameState = payload.gameState; updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime);
                    players = payload.players || []; ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2, vx: 0, vy: 0, ownerId: null };
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    if (payload.allTournamentTeams && Array.isArray(payload.allTournamentTeams)) { populateTeamList(payload.allTournamentTeams); }
                    if (currentGameState === 'FULL_TIME' && payload.nextMatch) { nextMatchInfo = payload.nextMatch; console.log("Storing next match info from fullGameState:", nextMatchInfo); updateTeamUI(nextMatchInfo.teamA, nextMatchInfo.teamB, nextMatchInfo.oddsA, nextMatchInfo.oddsB, 'bettingOnly'); updateTeamUI(serverTeamA, serverTeamB, null, null, 'scoreBarOnly'); } else { updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); nextMatchInfo = null; }
                    handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'initialWait':
                    console.log("Handling initialWait");
                    serverTeamA = payload.teamA; serverTeamB = payload.teamB; serverOddsA = payload.oddsA; serverOddsB = payload.oddsB; currentGameState = 'INITIAL_BETTING';
                    updateScoreAndTime(0, 0, 0); players = []; ball = { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    if (payload.allTournamentTeams && Array.isArray(payload.allTournamentTeams)) { populateTeamList(payload.allTournamentTeams); } // Ensure list populates on initial wait too
                    break;
                case 'preMatch':
                    console.log("Handling preMatch");
                    serverTeamA = payload.teamA; serverTeamB = payload.teamB; serverOddsA = payload.oddsA; serverOddsB = payload.oddsB; currentGameState = 'PRE_MATCH'; nextMatchInfo = null;
                    updateScoreAndTime(0, 0, 0); updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'matchStart':
                    console.log("Handling matchStart");
                    serverTeamA = payload.teamA || serverTeamA; serverTeamB = payload.teamB || serverTeamB; serverOddsA = payload.oddsA || serverOddsA; serverOddsB = payload.oddsB || serverOddsB; currentGameState = 'FIRST_HALF'; nextMatchInfo = null;
                    updateScoreAndTime(0, 0, 0); updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'gameStateUpdate':
                    updateScoreAndTime(payload.scoreA, payload.scoreB, payload.serverGameTime); players = payload.players || []; ball = payload.ball || { x: FIELD_WIDTH / 2, y: FIELD_HEIGHT / 2 };
                    if(payload.stats) { updateStatsUI(payload.stats); }
                    break;
                case 'goalScored':
                    console.log("Handling goalScored");
                    lastScoreA = payload.scoreA; lastScoreB = payload.scoreB; updateScoreAndTime(payload.scoreA, payload.scoreB);
                    addChatMessage("System", `⚽ GOAL! ${payload.scoringTeam === 'A' ? (serverTeamA?.name || 'Team A') : (serverTeamB?.name || 'Team B')} scores! (${payload.scoreA}-${payload.scoreB})`);
                    goalsAEl.textContent = payload.scoreA; goalsBEl.textContent = payload.scoreB;
                    canvas.style.transition = 'none'; canvas.style.backgroundColor = '#FFF'; setTimeout(() => { canvas.style.transition = 'background-color 0.5s ease'; canvas.style.backgroundColor = '#2a8c3e'; }, 100);
                    break;
                case 'halfTime':
                    console.log("Handling halfTime");
                    currentGameState = 'HALF_TIME'; updateScoreAndTime(payload.scoreA, payload.scoreB, 45 * 60); lastScoreA = payload.scoreA; lastScoreB = payload.scoreB; nextMatchInfo = null;
                    updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'secondHalfStart':
                    console.log("Handling secondHalfStart");
                    currentGameState = 'SECOND_HALF'; nextMatchInfo = null; updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'fullTime':
                    console.log("Handling fullTime", payload);
                    currentGameState = 'FULL_TIME'; updateScoreAndTime(payload.scoreA, payload.scoreB, 90 * 60); lastScoreA = payload.scoreA; lastScoreB = payload.scoreB; currentBet = null;
                    if (payload.nextMatch && payload.nextMatch.teamA && payload.nextMatch.teamB) { nextMatchInfo = payload.nextMatch; console.log("Stored next match info:", nextMatchInfo); updateTeamUI(nextMatchInfo.teamA, nextMatchInfo.teamB, nextMatchInfo.oddsA, nextMatchInfo.oddsB, 'bettingOnly'); updateTeamUI(serverTeamA, serverTeamB, null, null, 'scoreBarOnly'); } else { nextMatchInfo = null; updateTeamUI(serverTeamA, serverTeamB, serverOddsA, serverOddsB, 'all'); console.warn("FullTime message received without next match details."); }
                    handleGameStateChange(currentGameState, payload); checkBettingStatus();
                    break;
                case 'welcome':
                    console.log("Handling welcome");
                    userNickname = payload.nickname; userBalance = payload.balance; currentBet = payload.currentBet;
                    nicknameModalEl.style.display = 'none'; chatInputEl.disabled = false; sendChatBtn.disabled = false; chatInputEl.placeholder = "Type message...";
                    userBalanceEl.textContent = parseFloat(userBalance || 0).toFixed(2); // Ensure display on welcome
                    addChatMessage("System", `Welcome, ${userNickname}! Balance: $${parseFloat(userBalance || 0).toFixed(2)}.`);
                    checkBettingStatus();
                    break;
                case 'chatBroadcast':
                    addChatMessage(payload.sender, payload.message);
                    break;
                case 'betResult':
                    console.log("Handling betResult", payload);
                    setBetMessage(payload.message, !payload.success);
                    if (payload.newBalance !== undefined) {
                        userBalance = payload.newBalance; // Server sends the authoritative balance
                        userBalanceEl.textContent = parseFloat(userBalance || 0).toFixed(2); // Update display
                    }
                    if (payload.message.includes("placed") || payload.message.includes("WON!") || payload.message.includes("LOST") || payload.message.includes("refunded")) { if (!payload.message.includes("placed")) { currentBet = null; } }
                    checkBettingStatus(); // Re-evaluate betting buttons
                    break;
                 case 'systemMessage':
                     addChatMessage("System", `[Server: ${payload.message}]`); if (payload.isError) { setBetMessage(`Server: ${payload.message}`, true); }
                     break;
                 case 'leaderboardUpdate': // Handle new leaderboard message
                     console.log("Received leaderboard:", payload);
                     updateLeaderboardUI(payload);
                     break;
                default:
                    console.warn('Unknown message type received:', type);
                    break;
            }
        }

        // --- UI Update Functions ---
        function updateCoreMatchState(teamA, teamB, oddsA, oddsB, scoreA, scoreB, timeS) { serverTeamA = teamA; serverTeamB = teamB; serverOddsA = oddsA; serverOddsB = oddsB; lastScoreA = scoreA; lastScoreB = scoreB; updateScoreAndTime(scoreA, scoreB, timeS); }
        function updateTeamUI(teamA, teamB, oddsAVal, oddsBVal, target = 'all') { const nameA = teamA?.name || '---'; const nameB = teamB?.name || '---'; const initialsA = getPlayerInitials(nameA || 'A'); const initialsB = getPlayerInitials(nameB || 'B'); if (target === 'all' || target === 'scoreBarOnly') { teamANameEl.textContent = nameA; teamBNameEl.textContent = nameB; } if (target === 'all' || target === 'bettingOnly') { betTeamANameEl.textContent = nameA; betTeamBNameEl.textContent = nameB; oddsAEl.textContent = oddsAVal !== undefined && oddsAVal !== null ? parseFloat(oddsAVal).toFixed(2) : '?.??'; oddsBEl.textContent = oddsBVal !== undefined && oddsBVal !== null ? parseFloat(oddsBVal).toFixed(2) : '?.??'; } if (target === 'all' || target === 'scoreBarOnly') { statsTeamAHeaderEl.textContent = initialsA; statsTeamBHeaderEl.textContent = initialsB; } else if (target === 'bettingOnly' && serverTeamA && serverTeamB) { statsTeamAHeaderEl.textContent = getPlayerInitials(serverTeamA.name || 'A'); statsTeamBHeaderEl.textContent = getPlayerInitials(serverTeamB.name || 'B'); } }
        function updateScoreAndTime(sA, sB, timeS) { if (sA !== undefined && sA !== null) scoreAEl.textContent = sA; if (sB !== undefined && sB !== null) scoreBEl.textContent = sB; if (sA !== undefined && sA !== null) goalsAEl.textContent = sA; if (sB !== undefined && sB !== null) goalsBEl.textContent = sB; if (timeS !== undefined && timeS !== null) gameTimeEl.textContent = formatTime(timeS); if (sA !== undefined && sA !== null) lastScoreA = sA; if (sB !== undefined && sB !== null) lastScoreB = sB; }
        function updateStatsUI(statsData) { if (!statsData) return; const safeStat = (teamStat, key, defaultVal) => teamStat && teamStat[key] !== undefined && teamStat[key] !== null ? teamStat[key] : defaultVal; if(statsData.teamA) { shotsAEl.textContent = safeStat(statsData.teamA, 'shots', shotsAEl.textContent); passesAEl.textContent = safeStat(statsData.teamA, 'passes', passesAEl.textContent); } if(statsData.teamB) { shotsBEl.textContent = safeStat(statsData.teamB, 'shots', shotsBEl.textContent); passesBEl.textContent = safeStat(statsData.teamB, 'passes', passesBEl.textContent); } const passesA = parseInt(passesAEl.textContent) || 0; const passesB = parseInt(passesBEl.textContent) || 0; const totalPasses = passesA + passesB; if (totalPasses > 0) { possessionAEl.textContent = Math.round((passesA / totalPasses) * 100) + '%'; possessionBEl.textContent = Math.round((passesB / totalPasses) * 100) + '%'; } else { possessionAEl.textContent = '50%'; possessionBEl.textContent = '50%'; } }
        function populateTeamList(teamNames) { if (!teamListEl) return; teamListEl.innerHTML = ''; if (!teamNames || teamNames.length === 0) { const li = document.createElement('li'); li.textContent = 'Team list unavailable.'; teamListEl.appendChild(li); return; } teamNames.forEach(name => { const li = document.createElement('li'); li.textContent = name; teamListEl.appendChild(li); }); }
        function updateLeaderboardUI(leaderboardData) { // NEW Function
             if (!leaderboardEl) return;
             leaderboardEl.innerHTML = '';
             if (!leaderboardData || leaderboardData.length === 0) { const li = document.createElement('li'); li.textContent = 'No bettors yet.'; li.classList.add('no-entries'); leaderboardEl.appendChild(li); return; }
             leaderboardData.forEach(entry => {
                 const li = document.createElement('li');
                 const nameSpan = document.createElement('span'); nameSpan.textContent = entry.nickname || 'Anonymous';
                 const balanceSpan = document.createElement('span'); const balanceValue = parseFloat(entry.balance || 0); balanceSpan.textContent = `$${balanceValue.toFixed(2)}`; balanceSpan.classList.add('leaderboard-balance');
                 li.appendChild(nameSpan); li.appendChild(balanceSpan); leaderboardEl.appendChild(li);
             });
         }

        // --- Game State Change & Timers ---
        function hideOverlays() { initialWaitOverlayEl.style.display = 'none'; halftimeOverlayEl.style.display = 'none'; fulltimeOverlayEl.style.display = 'none'; }
        function handleGameStateChange(newState, payload) { hideOverlays(); clearTimeout(breakTimerInterval); breakEndTime = payload?.breakEndTime; let statusText = ""; let overlayTimerEl = null; let overlayPrefix = ""; const nameA = serverTeamA?.name || 'Team A'; const nameB = serverTeamB?.name || 'Team B'; const scoreStr = `${lastScoreA} - ${lastScoreB}`; switch (newState) { case 'INITIALIZING': statusText = "Initializing..."; break; case 'INITIAL_BETTING': initialWaitOverlayEl.style.display = 'flex'; initialWaitDetailsEl.textContent = `Betting open: ${nameA} vs ${nameB}`; statusText = `Betting open for first match: ${nameA} vs ${nameB}!`; overlayTimerEl = initialTimerDisplayEl; overlayPrefix = "First match starts in: "; break; case 'PRE_MATCH': statusText = `Starting Soon: ${nameA} vs ${nameB}. Betting closing...`; break; case 'FIRST_HALF': statusText = `Match Running: ${nameA} ${scoreAEl.textContent}-${scoreBEl.textContent} ${nameB} (1st Half)`; break; case 'HALF_TIME': halftimeOverlayEl.style.display = 'flex'; halftimeDetailsEl.textContent = `Score: ${nameA} ${scoreStr} ${nameB}`; statusText = `Half Time: ${nameA} ${scoreStr} ${nameB}. Betting closed.`; overlayTimerEl = breakTimerDisplayEl; overlayPrefix = "2nd Half starts in: "; break; case 'SECOND_HALF': statusText = `Match Running: ${nameA} ${scoreAEl.textContent}-${scoreBEl.textContent} ${nameB} (2nd Half)`; break; case 'FULL_TIME': fulltimeOverlayEl.style.display = 'flex'; fulltimeDetailsEl.textContent = `Final Score: ${nameA} ${scoreStr} ${nameB}`; overlayTimerEl = nextMatchTimerDisplayEl; overlayPrefix = "Next match starts in: "; const nextNameA = nextMatchInfo?.teamA?.name || 'Next Team A'; const nextNameB = nextMatchInfo?.teamB?.name || 'Next Team B'; statusText = `Full Time: ${nameA} ${scoreStr} ${nameB}. Betting open for ${nextNameA} vs ${nextNameB}!`; break; default: statusText = "Waiting for server update..."; break; } gameStatusMessageEl.textContent = statusText; if (overlayTimerEl && breakEndTime) { startBreakTimer(overlayTimerEl, overlayPrefix); } }
        function startBreakTimer(displayElement, prefix) { clearTimeout(breakTimerInterval); const updateTimer = () => { if (!breakEndTime || !displayElement) { if(displayElement) displayElement.textContent = prefix + "00:00"; return; } const now = Date.now(); const timeLeftS = Math.max(0, Math.floor((breakEndTime - now) / 1000)); const mins = Math.floor(timeLeftS / 60); const secs = timeLeftS % 60; displayElement.textContent = `${prefix}${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`; if (timeLeftS > 0) { const msToNextSecond = 1000 - (now % 1000); breakTimerInterval = setTimeout(updateTimer, msToNextSecond); } else { displayElement.textContent = prefix + "00:00"; } }; updateTimer(); }

        // --- Drawing Functions ---
        function drawField() { ctx.fillStyle = '#2a8c3e'; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; ctx.lineWidth = 2; ctx.strokeRect(1, 1, canvas.width - 2, canvas.height - 2); ctx.beginPath(); ctx.moveTo(canvas.width / 2, 0); ctx.lineTo(canvas.width / 2, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, CENTER_CIRCLE_RADIUS * (canvas.width / FIELD_WIDTH), 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; ctx.beginPath(); ctx.arc(canvas.width / 2, canvas.height / 2, 5 * (canvas.width / FIELD_WIDTH) , 0, Math.PI*2); ctx.fill(); const goalDrawWidth = GOAL_WIDTH * (canvas.height / FIELD_HEIGHT); const goalDrawDepth = GOAL_DEPTH * (canvas.width / FIELD_WIDTH); ctx.fillStyle = 'rgba(200, 200, 200, 0.2)'; ctx.fillRect(0, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.fillRect(canvas.width - goalDrawDepth, (canvas.height - goalDrawWidth) / 2, goalDrawDepth, goalDrawWidth); ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)'; const penaltyAreaWidth = 165 * (canvas.width / FIELD_WIDTH); const penaltyAreaHeight = 403 * (canvas.height / FIELD_HEIGHT); ctx.strokeRect(0, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); ctx.strokeRect(canvas.width - penaltyAreaWidth, (canvas.height - penaltyAreaHeight) / 2, penaltyAreaWidth, penaltyAreaHeight); }
        function drawPlayer(player) { const canvasX = player.x * (canvas.width / FIELD_WIDTH); const canvasY = player.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = PLAYER_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = player.color || '#CCCCCC'; ctx.beginPath(); ctx.arc(canvasX, canvasY, canvasRadius, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = ball.ownerId === player.id ? '#FFFF00' : '#000000'; ctx.lineWidth = ball.ownerId === player.id ? 2.5 : 1; ctx.stroke(); ctx.fillStyle = player.textColor || '#000000'; ctx.font = `bold ${canvasRadius * 0.8}px sans-serif`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(player.initials || 'P?', canvasX, canvasY); }
        function drawBall() { const canvasX = ball.x * (canvas.width / FIELD_WIDTH); const canvasY = ball.y * (canvas.height / FIELD_HEIGHT); const canvasRadius = BALL_RADIUS * (canvas.width / FIELD_WIDTH); ctx.fillStyle = '#FFFFFF'; ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(canvasX, canvasY, Math.max(2, canvasRadius), 0, Math.PI * 2); ctx.fill(); ctx.stroke(); }
        function drawGame() { const currentWidth = canvas.clientWidth; const currentHeight = canvas.clientHeight; if (canvas.width !== currentWidth || canvas.height !== currentHeight) { canvas.width = currentWidth; canvas.height = currentHeight; } ctx.clearRect(0, 0, canvas.width, canvas.height); drawField(); if (players && players.length > 0) { players.forEach(drawPlayer); } if (ball) { drawBall(); } }

        // --- Client Rendering Loop ---
        function mainLoop() { drawGame(); animationFrameId = requestAnimationFrame(mainLoop); }
        function startRendering() { if (!animationFrameId) { animationFrameId = requestAnimationFrame(mainLoop); } }
        function stopRendering() { if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } }

        // --- Utility Functions (Client-side) ---
        function formatTime(ingameSeconds) { const totalSeconds = Math.max(0, Math.floor(ingameSeconds)); const minutes = Math.floor(totalSeconds / 60); const seconds = totalSeconds % 60; return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`; }
        function addChatMessage(sender, message) { const messageEl = document.createElement('div'); const safeSender = sender.replace(/</g, "&lt;").replace(/>/g, "&gt;"); const safeMessage = message.replace(/</g, "&lt;").replace(/>/g, "&gt;"); messageEl.innerHTML = `<strong>${safeSender}:</strong> ${safeMessage}`; chatBoxEl.appendChild(messageEl); chatBoxEl.scrollTop = chatBoxEl.scrollHeight; }
        function setBetMessage(message, isError = false) { betMessageEl.textContent = message; betMessageEl.className = `bet-message ${isError ? 'bet-error' : ''}`; setTimeout(() => { if (betMessageEl.textContent === message) { checkBettingStatus(); } }, 4000); }
        function getPlayerInitials(name) { if (!name || typeof name !== 'string') return '??'; const parts = name.trim().split(' '); if (parts.length >= 2) { return (parts[0][0] + parts[parts.length - 1][0]).toUpperCase(); } else if (parts.length === 1 && name.length > 0) { return name.substring(0, Math.min(2, name.length)).toUpperCase(); } return '??'; }
        function disableInteraction(reason = "Disabled") { chatInputEl.disabled = true; sendChatBtn.disabled = true; chatInputEl.placeholder = reason; disableBetting(reason); }
        function disableBetting(message, isError = true) { betAmountInputEl.disabled = true; betButtonAEl.disabled = true; betButtonBEl.disabled = true; setBetMessage(message, isError); }
        function checkBettingStatus() { const isBettingPeriod = ( currentGameState === 'INITIAL_BETTING' || currentGameState === 'FULL_TIME' || currentGameState === 'PRE_MATCH' ); if (!userNickname) { disableBetting("Enter nickname to bet.", true); return; } const bettingTeamAName = betTeamANameEl.textContent || 'Team A'; const bettingTeamBName = betTeamBNameEl.textContent || 'Team B'; if (currentBet) { const betOnTeamName = currentBet.team === 'A' ? bettingTeamAName : bettingTeamBName; disableBetting(`Bet placed on ${betOnTeamName} ($${parseFloat(currentBet.amount || 0).toFixed(2)}). Waiting for result.`, false); return; } if (parseFloat(userBalance || 0) <= 0) { disableBetting("Balance is $0.00. Cannot place bets.", true); return; } if (isBettingPeriod) { betButtonAEl.disabled = false; betButtonBEl.disabled = false; betAmountInputEl.disabled = false; setBetMessage(`Betting open for ${bettingTeamAName} vs ${bettingTeamBName}!`, false); } else { disableBetting("Betting is closed.", true); } }

        // --- Event Listeners ---
        function placeBetHandler(team) { const amount = parseInt(betAmountInputEl.value, 10); const currentBalance = parseFloat(userBalance || 0); if (!isNaN(amount) && amount > 0 && amount <= currentBalance) { disableBetting("Placing bet...", false); currentBet = { team: team, amount: amount }; sendMessage('placeBet', { team: team, amount: amount }); } else if (amount > currentBalance) { setBetMessage("Insufficient balance.", true); currentBet = null; checkBettingStatus(); } else { setBetMessage("Invalid bet amount.", true); currentBet = null; checkBettingStatus(); } }

        // --- Initialization ---
        function init() {
            console.log("Client initializing...");
            submitNicknameBtn.addEventListener('click', () => { const nick = nicknameInputEl.value.trim(); if (nick && nick.length > 0 && nick.length <= 15) { sendMessage('setNickname', nick); } else { alert("Please enter a valid nickname (1-15 characters)."); } });
            nicknameInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter') submitNicknameBtn.click(); });
            sendChatBtn.addEventListener('click', () => { const message = chatInputEl.value.trim(); if (message) { sendMessage('chatMessage', message); chatInputEl.value = ''; } });
            chatInputEl.addEventListener('keypress', (e) => { if (e.key === 'Enter' && !sendChatBtn.disabled) sendChatBtn.click(); });
            betButtonAEl.addEventListener('click', () => placeBetHandler('A'));
            betButtonBEl.addEventListener('click', () => placeBetHandler('B'));
            disableInteraction("Connecting..."); userBalanceEl.textContent = '---';
            drawField(); startRendering(); connectWebSocket();
            console.log("Client init complete.");
        }

        window.onload = init;

    </script>
</body>
</html>
